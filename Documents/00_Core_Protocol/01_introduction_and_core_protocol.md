# ACP 核心协议: 介绍与基础

## 1. ACP 简介

**ACP (Abstract Cognition Protocol)** 是一种**基于认知实体**的抽象认知协作协议，旨在实现跨认知实体的智能交互。它定义了一套规范，使得不同的认知实体（`Cognitor`）能够通过 ACP 进行交流和协作，共同完成复杂的任务。

关键在于理解：ACP 关注的是**如何让不同的认知实体能够理解和执行语义上等效的指令，记录可追溯的处理过程，以实现协作**，而不是一种主要用于创造性表达或精确形式化描述的语言。

## 2. 核心原则

ACP 协议的设计基于以下核心原则：

*   **跨载体兼容**: ACP 协议本身不依赖于 `Cognitor` 的具体实现。同一段 ACP 交互理论上可由不同类型、不同能力的 `Cognitor`（AI、人类等）参与和处理。
*   **能力导向**: 协议不限定 `Cognitor` 的技术实现细节，仅要求其具备核心认知能力（学习、推理、元认知），协议是调用这些能力的接口。
*   **过程可审计**: 协议强制要求通过结构化的日志系统 (`Logs`) 实现执行过程的透明化，使交互历史、决策路径和状态变化可被追溯和理解。
*   **动态扩展**: 协议在设计上支持运行时切换或组合不同 `Cognitor` 的可能性（理论层面），以适应复杂任务的需求。
*   **基础可执行性**: ACP 的核心协议（定义了基本概念、交互流程和日志要求）辅以示例，本身就构成了可运行的基础。其他组件（如标准库、交互界面）是增强功能和易用性的，而非运行所必需。

## 3. 核心实体

ACP 协议围绕两个核心抽象实体进行定义：

### 3.1. Cognitor (认知实体)
*   **定义**: 指任何具备协议所要求的核心认知能力（**学习、推理、元认知**）的执行实体。它是 ACP 指令的最终理解者和执行能力的来源，其具体形态（如人工智能、人类个体/团队）对协议而言是透明的。协议通过 `Cognitor` 的这些内在能力运作。
*   **协议要求**: ACP 的有效运行 **依赖于** `Cognitor` 能够发挥上述三种认知能力。协议本身不提供这些能力。
*   **识别机制**: 协议包含 `CognitorInfo` 机制，用于存储和传达当前参与交互的具体 `Cognitor` 实例的元信息（如名称、类型、能力简介等）。

### 3.2. Cognitive Arena （认知领域）
*   **定义**: 简称 `Arena` 由一个或多个 `Cognitor` 根据协议规则维护的，可以互动、协作的抽象环境，类似于一个舞台或一个游戏场地。其核心职责是管理一个**基于Module**的交互上下文（`ArenaContext`），并基于该上下文协调 `Cognitor` 的活动，确保交互流程遵循协议规范（如过程透明性）。它本身不拥有智能，而是 `Cognitor` 发挥能力的平台和 ACP 交互的协调者。
*   **上下文管理**: `ArenaContext` 以某种形式的数据（具体形式由实现决定，如文本，音频，图像）记录交互历史、状态信息。所有未显式记录在上下文中的信息都可能在跨 `Cognitor` 或长时间交互中丢失。
*   **运作方式**: `Arena` 依赖 `Cognitor` 来理解上下文、解析指令、执行操作并生成符合协议的日志。其行为模式（如路由、错误处理）由 `Cognitor` 对协议的理解和模拟能力决定。
*   **关键协议特性**: 设计上强调**载体无关性**（可由不同 `Cognitor` 实现）和**过程透明性**（强制通过 `Logs` 记录）。

## 4. 交互基础

### 4.1. 认知指令 (Cognitive Directive)
*   **定义**: 指任何旨在传达指令、数据或查询的指令。协议不强制规定严格的结构，而是强调指令对于目标 `Cognitor` 必须具有足够的**清晰度和可理解性**，以允许其被正确解析和执行。语句的有效性由 `Cognitor` 的理解能力来界定。

### 4.2. 认知本体：信息结构基础 (Cognitive Ontology: Information Structure Basics)

ACP 协议定义了一个基础的**认知本体 (Cognitive Ontology)** 来结构化其处理的信息。这个本体的核心在于区分**确定性 (Determinism)** 与**不确定性 (Uncertainty)**，将其视为信息存在的基本状态。

#### Object (存在物/对象)

*   **定义**: ACP 认知本体中的**最高层抽象基类** (Top-level Abstract Base Class)。它代表**任何可被 `Cognitor` 思考、感知、指代或讨论的事物 (Thing)** 的最基本形式。所有下述的 `Module` 和 `Uncertainty` 等特定概念都继承自 `Object`，是这个本体论中的基本“存在物”。

#### Uncertainty (不确定性实体)
*继承于 Object*

*   **定义**: 代表 ACP 认知本体中的一个**可管理的、带有约束的不确定状态 (Managed Unresolved State with Constraints)**。它标记了信息中的一个节点，其具体指代、数值、属性或含义尚未完全确定，需要通过 `Cognitor` 的认知过程来逐步明晰。`Uncertainty` 不关心不确定性的来源或类型，仅提供一个通用的机制来添加和管理约束，以限制其存在的可能性空间。
*   **约束**: 任何类型的约束（例如，取值范围、概率分布、语法规则、形状定义等）都可以施加于一个 `Uncertainty` 存在物上，以缩减其可能性。
*   **持久性**: 无论约束如何增加，可能性空间如何缩小，`Uncertainty` 本身不会自动转变为一个 `Module` 实体。其“不确定性”的本质状态会持续存在。
*   **交互**: 在 `Runtime` 环境中，对 `Uncertainty` 的交互和解读需要通过详细的 `Log` 来记录施加的约束和推断过程，目的是降低不同 `Cognitor` 对同一个 `Uncertainty` 认知的偏差。

#### Module (确定性实体)
*继承于 Object*

*   **定义**: **确定性信息载体 (Deterministic Information Carrier)**。代表具有明确定义、形式确定、可预测、可验证特性的**存在形式或信息媒介 (Form or Medium)**。这包括但不限于：一个具体的数值、一段明确的文本、一段特定的声音、一张具体的图像、一个已定义的函数签名、一个完全实例化的数据结构、一条明确定义的语法规则等。
*   **角色**: `Module` 对应于那些需要处理的、形式上确定的“**数据**”或“**能指 (Signifier)**”。其关键在于**形式上的确定性 (Formal Determinism)**，它是承载和传递意义的基础结构，但其自身不包含主观解释或内在的不确定性。

#### Symbol (符号)
*继承于 Object*
注：当前 `Symbol` 范围定义需要进一步明确和细化。

*   **构想**: `Symbol` 旨在将可被感知的符号现象（能指）与其可能蕴含的意义（所指）联系起来，并明确认知解读在此过程中的核心作用。在 ACP 认知本体中，`Symbol` 可以被视为一种特殊的结构，它包含：
    *   **能指 (Signifier):** 一个或多个 `Module`。这是符号的外在、可感知的形式，是 `Cognitor` 感知的直接输入。它是形式确定的，是有意识层面的。
    *   **所指 (Signified):** 一个核心的 `Uncertainty`，其可能性空间通过“能指”以及 `Cognitor` 的解读来约束。这是符号内在的概念、意义或意图，是 `Cognitor` 理解的目标。所指本质上总是滑动的、开放的，带有无意识层面的影响。
    *   **认知实体 (Cognitor):** 指定或关联负责处理该 `Symbol` 的 `Cognitor`，该 `Cognitor` 提供了将“能指”转化为可能的“所指”的解读能力。

## 5. 关键协议机制

协议定义了几个关键机制来确保其核心原则的实现：

### 5.1. Logs (日志系统)
*   **定义**: ACP 协议规定的**强制性机制**，是协作有效性的核心，基于`元认知`功能。要求 `Arena` (及其 `Cognitor`) 以 `Module` 记录其关键执行步骤、内部状态变化、决策依据、解释、警告和错误，以确保**过程透明性和可审计性**。
* **目标**: 降低 `ArenaContext` 在不同 `Cognitor` 之间的认知偏差。

### 5.2. `meta` (元认知指令关键字)
*   **定义**: ACP 协议中的一个关键字，用于显式指示执行后续指令的 `Cognitor` 必须**调用其内在的元认知能力**。这要求 `Cognitor` 对自身的处理过程、状态、或对协议/上下文的理解进行反思和分析，以处理自我指涉、复杂推理或需要更高层抽象的任务。协议通过 `meta` 提供了一个标准接口来请求 `Cognitor` 进行更高层次的认知活动。
