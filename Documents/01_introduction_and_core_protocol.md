# ACP 核心协议: 介绍与基础

## 1. ACP 简介

**ACP (Abstract Cognition Protocol)** 是一种**基于文本**的抽象认知协作协议，旨在实现跨认知实体的智能交互。它定义了一套规范，使得不同的认知实体（`Cognitor`）能够通过 ACP 进行交流和协作，共同完成复杂的任务。

关键在于理解：ACP 关注的是**如何让不同的认知实体能够理解和执行语义上等效的指令，记录可追溯的处理过程，以实现协作**，而不是一种主要用于创造性表达或精确形式化描述的语言。

## 2. 核心原则

ACP 协议的设计基于以下核心原则：

*   **纯文本交互**: ACP 的交互媒介是纯文本。所有指令、数据和元信息都以文本形式交换。即使 `Runtime` 通过 `Cognitor` 模拟了函数、变量等高级概念，其状态和行为也必须通过文本日志进行记录和维护，以确保跨载体的一致性和可审计性。
*   **跨载体兼容**: ACP 协议本身不依赖于 `Cognitor` 的具体实现。同一段 ACP 交互理论上可由不同类型、不同能力的 `Cognitor`（AI、人类等）参与和处理。
*   **能力导向**: 协议不限定 `Cognitor` 的技术实现细节，仅要求其具备核心认知能力（学习、推理、元认知），协议是调用这些能力的接口。
*   **过程可审计**: 协议强制要求通过结构化的日志系统 (`Logs`) 实现执行过程的透明化，使交互历史、决策路径和状态变化可被追溯和理解。
*   **动态扩展**: 协议在设计上支持运行时切换或组合不同 `Cognitor` 的可能性（理论层面），以适应复杂任务的需求。
*   **基础可执行性**: ACP 的核心协议（定义了基本概念、交互流程和日志要求）辅以示例，本身就构成了可运行的基础。其他组件（如标准库、交互界面）是增强功能和易用性的，而非运行所必需。

## 3. 核心实体

ACP 协议围绕两个核心抽象实体进行定义：

### 3.1. Cognitor (认知执行体)
*   **定义**: 指任何具备协议所要求的核心认知能力（**学习、推理、元认知**）的执行实体。它是 ACP 指令的最终理解者和执行能力的来源，其具体形态（如人工智能、人类个体/团队）对协议而言是透明的。协议通过调用 `Cognitor` 的这些内在能力来运作。
*   **协议要求**: ACP 的有效运行**依赖于** `Cognitor` 能够发挥上述三种认知能力。协议本身不提供这些能力。
*   **识别机制**: 协议包含 `Cognitor.info` 机制，用于存储和传达当前参与交互的具体 `Cognitor` 实例的元信息（如名称、类型、能力简介等）。

### 3.2. Runtime (运行时环境)
*   **定义**: 一个由一个或多个 `Cognitor` 根据协议规则**模拟和维护**的抽象执行环境。其核心职责是管理**纯文本格式**的交互上下文 (`Runtime.context`)，并基于该上下文协调 `Cognitor` 的活动，确保交互流程遵循协议规范（如过程透明性）。它本身不拥有智能，而是 `Cognitor` 发挥能力的平台和 ACP 交互的协调者。
*   **上下文管理**: `Runtime.context` 以纯文本形式（具体格式由实现决定，如 XML）记录交互历史、状态信息。所有未显式记录在上下文中的信息都可能在跨 `Cognitor` 或长时间交互中丢失。
*   **运作方式**: `Runtime` 依赖 `Cognitor` 来理解上下文、解析指令、执行操作并生成符合协议的日志。其行为模式（如路由、错误处理）由 `Cognitor` 对协议的理解和模拟能力决定。
*   **关键协议特性**: 设计上强调**载体无关性**（可由不同 `Cognitor` 实现）和**过程透明性**（强制通过 `Logs` 记录）。

## 4. 交互基础

### 4.1. ACP 语句 (ACP Statements)
*   **定义**: 指任何旨在传达指令、数据或查询的**文本片段**。协议不强制规定严格的语法，而是强调语句对于目标 `Cognitor` 必须具有足够的**清晰度和可理解性**，以允许其被正确解析和执行。语句的有效性由 `Cognitor` 的理解能力来界定。

### 4.2. 信息表示基础 (`Object`, `Module`, `Uncertainty`, `LingUnit`)

ACP 协议定义了基础的对象模型来处理信息，其核心在于区分确定性与不确定性，以及对自然语言的特殊处理：

*   **`Object`** : ACP 中所有可被 `Cognitor` 思考、感知或讨论的事物的**抽象基类**。所有 `Module`、`Uncertainty` 和 `LingUnit` 都是 `Object` 的子类型。

*   **`Module`** : 代表**确定性信息单元 (Deterministic Information Unit)** 。这类信息具有明确定义、可预测、可验证的特性（例如，一个具体的数值、一个已定义的函数签名、一个完全实例化的数据结构、一条明确定义的语法规则）。`Module` 对应于传统计算中处理的结构化或固定数据。

*   **`Uncertainty`** : 代表 ACP 协议中的一个**抽象的、可管理的不确定性状态 (Managed Unresolved State with Constraints)**。它标识了信息中的一个点，其具体含义、数值或属性尚未完全确定，需要通过 `Cognitor` 的处理来逐步明确。`Uncertainty` 本身不对不确定性的来源或类型做任何限制，只提供一个通用的约束添加和管理机制。任何类型的约束（例如，取值范围、概率分布、语法规则）都可以添加到 `Uncertainty` 对象上，以缩小其可能性空间。

*   **`LingUnit`** : 代表 ACP 协议中的一个**语言单元 (Linguistic Unit)，是专门用于处理自然语言不确定性的 `Uncertainty` 的子类型**。`LingUnit` 将自然语言视为一种需要认知解读的“不确定性”，并提供了一套用于表达、关联和解析语言信息的机制。每个 `LingUnit` 包含以下关键组成部分：
      *   **能指 (Signifier):** 具体的文本表示（字符串）。这是 `LingUnit` 的外在形式，也是 `Cognitor` 感知的直接输入。
      *   **所指 (Signified):** 概念、意义、意图。这是 `LingUnit` 的内在含义，也是 `Cognitor` 试图理解的目标。所指本身可以是一个 `Module`（如果含义明确），也可以是一个嵌套的 `Uncertainty`（如果含义仍然不确定）。
      *   **关联知识库/上下文:** 一个或多个 `Module`，用于指定用于解释该 `LingUnit` 的显式知识库资源。
      *   **关联语法 (Optional):** 一个或多个 `Module`，用于定义该 `LingUnit` 的语法结构和规则。

**补充说明:**

*   **自然语言皆为 `LingUnit`:** 在 ACP 中，所有被 `Cognitor` 感知的自然语言片段都将被自动转换为 `LingUnit` 对象进行处理。
*   **显式知识库的应用:** `Cognitor` 在处理 `LingUnit` 时，会首先根据其关联的知识库资源来尝试填充“所指”部分。
*   **“生成语法”机制:** `Cognitor` 可以利用与 `LingUnit` 关联的语法规则来解析、验证或生成符合特定结构的自然语言片段。

## 5. 关键协议机制

协议定义了几个关键机制来确保其核心原则的实现：

### 5.1. Logs (日志系统)
*   **定义**: ACP 协议规定的**强制性机制**，要求 `Runtime` (及其 `Cognitor`) 以结构化的文本格式记录其关键执行步骤、内部状态变化、决策依据、警告和错误，以确保**过程透明性和可审计性**。日志条目包含来源、级别和消息等核心元数据。

### 5.2. `meta` (元认知指令关键字)
*   **定义**: ACP 协议中的一个关键字，用于显式指示执行后续指令的 `Cognitor` 必须**调用其内在的元认知能力**。这要求 `Cognitor` 对自身的处理过程、状态、或对协议/上下文的理解进行反思和分析，以处理自我指涉、复杂推理或需要更高层抽象的任务。协议通过 `meta` 提供了一个标准接口来请求 `Cognitor` 进行更高层次的认知活动。
