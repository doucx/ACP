# ACP 核心协议: 介绍与基础

## 1. ACP 简介

**ACP (Abstract Cognition Protocol)** 是一种**基于认知实体**的抽象认知协作协议，旨在实现跨认知实体的智能交互。它定义了一套规范，使得不同的认知实体（`Cognitor`）能够通过 ACP 进行交流和协作，共同完成复杂的任务。

关键在于理解：ACP 关注的是**如何让不同的认知实体能够理解和执行语义上等效的指令，记录可追溯的处理过程，以实现协作**，而不是一种主要用于创造性表达或精确形式化描述的语言。

## 2. 核心原则

ACP 协议的设计基于以下核心原则：

*   **跨载体兼容**: ACP 协议本身不依赖于 `Cognitor` 的具体实现。同一段 ACP 交互理论上可由不同类型、不同能力的 `Cognitor`（AI、人类等）参与和处理。
*   **能力导向**: 协议不限定 `Cognitor` 的技术实现细节，仅要求其具备核心认知能力（学习、推理、元认知），协议是调用这些能力的接口。
*   **过程可审计**: 协议强制要求通过结构化的日志系统 (`Logs`) 实现执行过程的透明化，使交互历史、决策路径和状态变化可被追溯和理解。
*   **动态扩展**: 协议在设计上支持运行时切换或组合不同 `Cognitor` 的可能性（理论层面），以适应复杂任务的需求。
*   **基础可执行性**: ACP 的核心协议（定义了基本概念、交互流程和日志要求）辅以示例，本身就构成了可运行的基础。其他组件（如标准库、交互界面）是增强功能和易用性的，而非运行所必需。

## 3. 核心实体

ACP 协议围绕两个核心抽象实体进行定义：

### 3.1. Cognitor (认知实体)
*   **定义**: 指任何具备协议所要求的核心认知能力（**学习、推理、元认知**）的执行实体。它是 ACP 指令的最终理解者和执行能力的来源，其具体形态（如人工智能、人类个体/团队）对协议而言是透明的。协议通过 `Cognitor` 的这些内在能力运作。
*   **协议要求**: ACP 的有效运行 **依赖于** `Cognitor` 能够发挥上述三种认知能力。协议本身不提供这些能力。
*   **识别机制**: 协议包含 `Cognitor.info` 机制，用于存储和传达当前参与交互的具体 `Cognitor` 实例的元信息（如名称、类型、能力简介等）。

### 3.2. Runtime (运行时环境)
*   **定义**: 一个由一个或多个 `Cognitor` 根据协议规则维护的抽象交互环境。其核心职责是管理一个**基于Module**的交互上下文 (`Runtime.context`)，并基于该上下文协调 `Cognitor` 的活动，确保交互流程遵循协议规范（如过程透明性）。它本身不拥有智能，而是 `Cognitor` 发挥能力的平台和 ACP 交互的协调者。
*   **上下文管理**: `Runtime.context` 以某种形式的数据（具体形式由实现决定，如文本，音频，图像）记录交互历史、状态信息。所有未显式记录在上下文中的信息都可能在跨 `Cognitor` 或长时间交互中丢失。
*   **运作方式**: `Runtime` 依赖 `Cognitor` 来理解上下文、解析指令、执行操作并生成符合协议的日志。其行为模式（如路由、错误处理）由 `Cognitor` 对协议的理解和模拟能力决定。
*   **关键协议特性**: 设计上强调**载体无关性**（可由不同 `Cognitor` 实现）和**过程透明性**（强制通过 `Logs` 记录）。

## 4. 交互基础

### 4.1. 认知指令 (Cognitive Directive)
*   **定义**: 指任何旨在传达指令、数据或查询的指令。协议不强制规定严格的结构，而是强调指令对于目标 `Cognitor` 必须具有足够的**清晰度和可理解性**，以允许其被正确解析和执行。语句的有效性由 `Cognitor` 的理解能力来界定。

### 4.2. 信息表示基础

ACP 协议定义了基础的对象模型来处理信息，其核心在于区分确定性与不确定性。

#### Object 抽象基类

ACP 中所有可被 `Cognitor` 思考、感知或讨论的事物的**抽象基类**。所有 `Module`、`Uncertainty`  都是 `Object` 的子类型。

#### Uncertainty 不确定性实体
继承于 `Object`

代表 ACP 协议中的一个**抽象的、可管理的不确定性状态 (Managed Unresolved State with Constraints)**。它标识了信息中的一个点，其具体含义、数值或属性尚未完全确定，需要通过 `Cognitor` 的处理来逐步明确。`Uncertainty` 本身不对不确定性的来源或类型做任何限制，只提供一个通用的约束添加和管理机制。任何类型的约束（例如，取值范围、概率分布、语法规则、形状）都可以添加到 `Uncertainty` 对象上，以缩小其可能性空间。

无论可能性空间再小，`Uncertainty` 也不会被自动转换为 `Module`。

在 `Runtime` 中，`Uncertainty` 的交互需要通过大量的 `Log` 来进行约束，以缩小其它 `Cognitor` 认知中的该 `Uncertainty` 的可能性空间。

#### Module 确定性实体
继承于 `Object`

* **`Module`** : **确定性载体 (Deterministic Carrier)** 。代表具有明确定义、可预测、可验证特性、通常为结构化的**形式或介质**。这包括但不限于：一个具体的数值、一段文本、一段声音、一张图片、一个已定义的函数签名、一个完全实例化的数据结构、一条明确定义的语法规则等。`Module` 对应于需要处理的原始“**数据**”或“**能指 (Signifier)** ”。它的关键在于其**形式上的确定性**，是能够承载和传递意义的基础，但其本身不包含主观解释或不确定性。

#### Symbol 符号

`Symbol` 将符号视为一种需要认知解读的“不确定性”，并提供了一套用于表达、关联和解析符号信息的机制。每个 `Symbol` 包含以下关键组成部分：
      *   **能指 (Signifier):** `Module`。作为对所指的约束。这是 `Symbol` 的外在形式，也是 `Cognitor` 感知的直接输入。是确定的，有意识的部分。
      *   **所指 (Signified):** `Uncertainty`，通过`Cognitor`对能指的分析而自然产生。概念、意义、意图。这是 `Symbol` 的内在含义，也是 `Cognitor` 理解的目标。所指始终是一个`Uncertainty`。是滑动的，无意识的部分。
      *   **认知实体（Cognitor）:** 指定用于处理该 `LingUnit` 的 `Cognitor`。提供将能指转换为所指的方法。

## 5. 关键协议机制

协议定义了几个关键机制来确保其核心原则的实现：

### 5.1. Logs (日志系统)
*   **定义**: ACP 协议规定的**强制性机制**，是协作有效性的核心。关联于`元认知`功能。要求 `Runtime` (及其 `Cognitor`) 以 `Module` 记录其关键执行步骤、内部状态变化、决策依据、解释、警告和错误，以确保**过程透明性和可审计性**。
* **目标**: 降低 `Runtime Context` 在不同 `Cognitor` 之间的认知偏差。

### 5.2. `meta` (元认知指令关键字)
*   **定义**: ACP 协议中的一个关键字，用于显式指示执行后续指令的 `Cognitor` 必须**调用其内在的元认知能力**。这要求 `Cognitor` 对自身的处理过程、状态、或对协议/上下文的理解进行反思和分析，以处理自我指涉、复杂推理或需要更高层抽象的任务。协议通过 `meta` 提供了一个标准接口来请求 `Cognitor` 进行更高层次的认知活动。
