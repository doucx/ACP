# NPL 协议概述

> 基于： [[1.1.1_protocol_requirements]], [[1.1.3.9_cognitive_trace_support]]

## 1. NPL 的本质：结合结构化约束与自然语言定义的认知指令系统

**核心定位**: NPL (Natural Pseudo Language) 是一个运行在 **`Cognitor` 内部概念性的“NPL 运行时” (NPL Runtime)** 环境中的、旨在创建结构化或半结构化文本**符号 (`Sign`)** 的系统。这些 NPL `Sign` 作为**认知指令 (`Cognitive Directive`, `CD`)**，为处理它们的 `Cognitor` 提供清晰的**约束 (`Constraint`)**，以精确地引导其内部的**符号过程 (Semiosis)**，使其形成的**解释项 (`Interpretant`)** 趋向于指令所意图的**对象 (`Object`)**。

NPL 通过两种核心机制实现这一目标：

1.  **编程语言隐喻**: 利用编程语言的结构（如变量赋值、库导入、方法调用、控制流）作为**源领域隐喻**，映射到 `Cognitor` 的内部认知活动（目标领域），提供精确的结构化 `Constraint`。
2.  **自然语言定义 (NLD)**: 允许使用自然语言作为核心指导来定义认知任务或概念数据，同时通过 NPL 的接口和结构提示来约束，充分利用 `Cognitor` 的自然语言理解能力。

这两种机制相辅相成，使得 NPL 成为一个强大的、能够有机结合结构化精确性与自然语言灵活性的混合认知指令系统。

### 1.1 NPL 运行时 (NPL Runtime) 概念

* 每个 `Cognitor` 内部都包含一个概念性的 NPL 运行时环境。
* 这个运行时负责处理（解释并遵循）NPL `Sign` (CDs)，无论是基于编程隐喻的指令还是 NLD 定义的调用。
* 它维护着当前 NPL 代码执行的状态，包括已定义的 `Datum` 句柄及其指向的 `Sign` 。
* NPL 的“执行”是在这个运行时中，由 `Cognitor` 的认知能力（包括结构化处理和自然语言理解）驱动的符号过程。

### 1.2 机制解释

* **编程隐喻**:
    * 提供精确的**句法和结构语义** `Constraint`。
    * 利用 `Cognitor` 已有的结构化处理能力。
    * 映射到认知活动：赋值 (`=`) 映射到建立内部引用；方法调用 (`.`) 映射到应用特定认知模式；控制流 (`if`, `for`) 映射到模拟执行流程。
* **自然语言定义 (NLD)** (见 [[1.1.3.4_nld_mechanism]]):
    * 提供 `nld proc`/`nld data` 等语法，让 NL 可以直接定义可调用的过程和可引用的数据结构。
    * 将 NL 理解作为核心执行机制之一，使语义基础更丰富。
    * 允许用 NL 定义不适合编程隐喻的复杂认知任务。
    * NLD 使符号学关联更清晰：NL 主体作为 Representamen，NPL 接口/类型提示作为强 Constraint，认知理解过程是 Semiosis，最终符合结构的结果是 Interpretant 的外显。
    * **认知执行**: `Cognitor` 理解 NLD 的 NL 主体，并根据 NPL 接口约束执行符号过程。
* **强制 CT**: 无论是处理基于隐喻的 NPL 还是执行 NLD，`Cognitor` 都**必须**通过详尽的 `CT` 记录其内部符号过程，特别是 NLD 的执行过程，以保证透明度和可追溯性。

**关键前提**: NPL 的力量源于 `Cognitor` 对 NPL `Sign`（包括 NLD）的**理解**以及在其内部 NPL 运行时中**遵循其指导**进行符号过程的能力。**它不是外部代码执行，而是内部认知引导**。

## 2. NPL 的核心目标与哲学

1.  **认知指令 (`CD`)**: NPL 是创建和传递 `CD` 的工具，旨在影响接收方 `Cognitor` 在其 NPL 运行时中的符号过程。
2.  **认知运行时处理**: `Cognitor` 在其 NPL 运行时中处理 NPL `Sign`（包括解释 NLD 的 NL 部分），这是一个内部符号过程。
3.  **面向内部状态与概念**: NPL 主要用于引导 `Cognitor` 在其 NPL 运行时中创建、配置和操作概念性对象或数据（可通过编程隐喻或 NLD 定义），或管理其内部追踪的状态。
4.  **依赖原生理解力**: 结构化（编程隐喻、NLD 接口）是为了辅助 `Cognitor` 的符号处理和 NL 理解能力。
5.  **结果外显化**: NPL 运行时处理（包括 NLD 执行）的结果，最终通过特定指令（如 `canvas.render`）**外显化**为添加到 `Space` 的新 `Sign` (XML Node) 或通过 `CT Sign` 记录下来。NLD 执行的结果必须符合其 `->` 类型/结构提示。
6.  **模块化与库**: 通过**库导入**的隐喻 (`import` 指令)，NPL 支持将特定领域的功能（可包含 NLD 定义）封装起来。
7.  **元编程指导**: 控制流等结构指导 `Cognitor` 在其 NPL 运行时中规划和模拟执行流程，并通过 `CT` 记录。NLD 过程本身也可以包含复杂的逻辑。

## 3. NPL 与符号学原理

* **NPL `Sign`**: 每个 NPL 语句/构造是一个结构化的 `Sign`，利用了编程隐喻或包含 NL 定义。
* **结构/接口 = 强 `Constraint`**: 语法结构、NLD 参数和 `->` 类型提示提供强约束，引导 `Semiosis`。
* **NL 定义 = 核心 Representamen**: NLD 中的 NL 主体是待理解的核心 `Representamen`。
* **目标 = 精确引导 `Interpretant`**: 减少歧义，使 `Cognitor` 形成的 `Interpretant`）更符合 `CD` 的意图 (`Object`)，并符合 NLD 的结构要求。
* **处理 NPL = 在 NPL Runtime 中执行受约束的 Semiosis**: `Cognitor` 在其 NPL 运行时中，根据 NPL `Sign`（包括理解 NLD 的 NL 部分）提供的 `Constraint` 进行符号过程。
* **`CT` 记录过程**: `Cognitor` **必须**通过 `CT Sign` 记录其在 NPL 运行时中处理 NPL `CD` 的关键符号过程，**尤其需要详尽记录 NLD 的解释和执行过程**。

## 4. 对 Cognitor 实现者的指导

实现能处理 NPL (包含 NLD) 的 `Cognitor` 意味着要实现其**内部的 NPL 运行时环境**，并具备相应的认知能力：

1.  **解析 NPL 语法**: 包括赋值、方法调用、控制流、`import` 以及 NLD 定义语法 (`nld proc/data/p/d`, `->`, `end/data`)。
2.  **实现 NPL 运行时状态管理**: 管理 `Datum` 句柄及其指向的 `Sign` 。
3.  **理解隐喻与 NL 定义**:
    * 将 NPL 编程结构映射到内部认知操作。
    * **具备强大的自然语言理解能力**，以解释 NLD 定义中的 NL 主体。
4.  **执行符号过程**:
    * 根据 NPL 结构化 `Constraint` 进行推理和状态更新。
    * **基于对 NLD NL 主体的理解**，结合 NPL 接口约束，执行相应的认知任务。
    * **确保 NLD 执行结果符合 `->` 类型/结构提示**。
5.  **实现核心 CD 模式与库支持**: 包括库导入、对象实例化（可能由 NLD 定义）、配置、渲染/外显化等。
6.  **记录 NPL 运行时 CT**: **详细记录**在 NPL 运行时中发生的符号过程，**对 NLD 的解释和执行过程给予特别关注**。
7.  **核心：模拟运行时，驱动认知**: 构建一个能够模拟脚本执行流程（包括调用和执行 NLD 定义），并以此驱动自身认知活动和与 `Space` 交互的内部机制。