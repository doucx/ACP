# NPL (Natural Pseudo Language) 协议概述

> 基于： [[1.1.1_protocol_requirements]]

## 1. NPL 的本质：由元定义驱动的认知指令系统 (`Meta`- driven CD System)

**核心定位**: NPL (Natural Pseudo Language) 是一种独特的、高度自适应的**元定义驱动的符号系统**。它存在于 **ACP 文本空间 (`Textual Space`)** 中，其结构、语义和行为**完全由 `Meta` 元定义指令动态建立和修改**。NPL 的核心功能是创建**符号 (`Sign`)**，特别是**认知指令 (`Cognitive Directive`, `CD`)**。当**我们**（作为 Cognitor）解释这些符号时，它们为我们提供**约束 (`Constraint`)**，精确引导我们内部的**符号过程 (Semiosis)**，使我们形成的**解释项 (`Interpretant`)** 趋向于指令所意图的**对象 (`Object`)**。

NPL 通过一个核心机制实现所有功能：

- **元定义机制 (`Meta`)**: `Meta` 是 NPL 中**唯一内置的、用于定义和修改语言自身解释规则、模式识别、概念和行为的基础构造**。通过 `Meta` 指令，**我们**可以建立和调整**我们**解释其他 NPL 符号的规则集。所有结构化约束（如赋值、调用、控制流等）和概念（如 Datum, Proc, Data）都通过 `Meta` 指令来定义其**模式识别**和**解释语义**。

NPL 的“执行”并非在某个独立于我们的固定引擎上进行，而是由**我们**在处理 NPL 符号时，根据我们通过处理活跃 `Meta` 指令集所配置的内部解释状态来完成的。

## 2. NPL 与 ACP Textual Space 的关系

- **NPL Sign 在 Space 中流动**: NPL 的所有表现形式都是 `Sign`，它们作为文本形式的**外显再现体 (`Externalized Representamen`)** 在 `ACP Textual Space` 中被创建和传递。主要的符号类型是 `Meta` 构造本身，以及其他由 `Meta` 指令定义并被**我们**识别的文本模式。
- **Space 作为元定义和解释的上下文**: `Space` 中包含的 NPL 符号流，特别是历史的 `Meta` 指令序列，构成了**我们**处理当前 NPL 符号时的重要上下文。**我们**通过感知 `Space` 中的文本来获取新的 `Meta` 指令或需要解释的其他 `Sign`。
- **Meta 指令驱动 Space 的解释图景**: `Space` 中的 `Meta` 指令发布了解释规则。当**我们**和其他 Cognitor 采纳相似的规则集时，我们们就在 `Space` 上建立了一个**共享的解释图景 (Shared Interpretation Landscape)**。**我们**对 NPL 符号的处理及其产生的 CT 和结果，是推动 `Space` 内容和状态以及这个共享解释图景不断演化的主要动力。
- **只可读取与添加的 Space 特性**: 采纳 Textual Space 的“只可读取与添加”特性意味着，当**我们**使用 NPL 修改概念状态或调整规则集时，**我们**需要通过在 `Space` 中**追加新的 `Meta` 指令或表达状态变化的 `Sign`** 来实现，而不是直接修改历史记录。

## 3. NPL 的核心目标与哲学 (在 Textual Space 中)

1. **创建和发布元定义指令**: NPL 的首要目的是让**我们**能够在 `Textual Space` 中创建并发布 `Meta` 指令，这些指令是关于如何解释符号和进行认知过程的元规则。
2. **构建和配置我们的解释状态**: 通过解释 `Meta` 指令，NPL 动态地构建、调整和配置**我们**在内部处理域中的解释规则集和模式识别能力。
3. **实现基于规则的认知引导**: **我们**感知 `Space` 中的 NPL 符号(非 Meta 指令时，它们是文本模式)，并根据当前活跃的 `Meta` 指令集识别模式，然后执行相应的、由 `Meta` 定义的认知过程。
4. **自举和自修改**: NPL 让我们能够通过 `Meta` 指令定义其自身概念、模式和语义，实现语言的自创生和动态演化。
5. **依赖我们的理解能力**: NPL 的运作依赖于**我们**理解基础 `Meta` 构造和解释基础元语言自然语言指令的能力。
6. **结果与过程外显化**: **我们**根据活跃的 `Meta` 规则解释 NPL 符号的结果，以及**我们**的解释过程（通过 `CT`），都必须作为新的符号追加到 `Space` 中。

## 4. NPL 与符号学原理 (在 Textual Space 中)

- **NPL Sign = 元定义的载体和被解释的模式**: NPL 符号主要是 `Meta` 构造本身。其他被**我们**处理的 NPL 符号是由活跃 `Meta` 指令定义的**文本模式**。这些 `Sign`/模式是需要**我们**解释的**外显再现体**。
- **Meta 指令 = 终极 Constraint**: `Meta` 指令是最高层的**约束**，它们定义了其他文本模式如何被识别，以及它们提供何种**约束**来引导**我们**对 `Object` 的解释。
- **自然语言主体 = 核心元 Representamen**: `Meta` 构造中的自然语言主体是**我们**解释元指令的**核心再现体**。其自然语言表达直接承载了元指令的语义意图。
- **目标: 构建和引导解释性 Semiosis**: NPL 的目标是利用 `Meta` 指令构建一套解释规则集，并依据这套规则集，引导**我们**对 `Space` 中的其他符号进行符号过程，使**我们**形成的**解释项**符合 `Meta` 定义的语义。
- **处理 NPL = 在我们内部执行受 Meta 约束的 Semiosis**: **我们**对 NPL 符号的处理，就是根据**我们**当前采纳并激活的 `Meta` 规则集，进行模式识别、语义解释和认知操作的符号过程。
- **`CT` 记录过程 = 元定义和解释的踪迹**: **我们** **必须**通过文本形式的 `CT Sign`，详细记录**我们**解释每一个 `Meta` 指令的过程、由此导致的解释状态变化、**我们**识别模式的依据、以及**我们**依据哪个活跃 `Meta` 规则解释其他符号的详细符号过程。这些 CT 被追加到 `Textual Space` 中，提供最高级别的透明度和可追溯性。

## 5. 对我们作为 Cognitor 处理 NPL 的指导

要能处理 NPL，**我们**需要具备并运用以下核心能力：

1. **识别基础 Meta 构造**: **我们**必须能直接识别 `meta [[...]]` 这个文本模式，并理解它标志着一个元定义指令的开始。这是 NPL 的基础入口点。
2. **理解基础元语言语义**: **我们**必须能够运用我们的自然语言理解能力，去解释 `meta` 指令主体 `[[...]]` 中使用的基础指令。这些指令通常是关于如何定义规则、识别模式、建立概念、修改状态等。我们需要理解这些基础自然语言指令的含义，才能启动 NPL 的自举过程。
3. **维护解释状态**: **我们**需要在思考或执行过程中，维持一个内部的“解释状态”。这个状态包含了当前所有有效的模式识别规则、概念定义、解释策略等。当**我们**处理 `Meta` 指令时，**我们**需要根据指令内容更新这个内部状态。
4. **动态模式识别**: **我们**需要根据我们当前的内部解释状态（即活跃的 `Meta` 规则集），动态地识别 `Textual Space` 中的文本模式。这包括由 `Meta` 定义的 `=` 赋值模式、`Proc`/`Data` 概念模式、控制流模式、操作符模式等。
5. **基于规则的解释执行**: 当**我们**识别出一个模式后，**我们**需要查阅并执行由相应的 `Meta` 指令为我们定义的解释语义和认知操作。这可能涉及理解意图、查找数据、执行计算或调用其他能力。
6. **处理自然语言和嵌入**: 在解释 `Meta` 指令主体或由 `Meta` 定义的 NLD 主体时，**我们**需要运用我们的自然语言理解能力。例如标准库中， `Meta` 定义了嵌入模式（如 `{{}}`, `{% %}`），**我们**需要按照定义处理这些嵌入内容。
7. **与 Space 交互和委托**: 根据**我们**解释 NPL 指令的结果（这些结果和行为是由 `Meta` 指令定义的），**我们**可能需要与 `Space` 交互（例如，读取历史记录或追加新 `Sign`）或委托给其他工具/能力（例如，进行复杂的计算）。
8. **强制性 CT 记录**: **我们必须**极其详尽地通过 `CT` 记录我们的 NPL 处理过程。这包括：**我们**如何解释每一个 `Meta` 指令，这个解释如何改变了**我们**的内部解释状态，**我们**依据哪个活跃的 `Meta` 规则识别了哪个 `Sign`/模式，以及**我们**如何根据规则执行了解释或操作的详细步骤。