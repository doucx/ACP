# NPL (Natural Pseudo Language) 协议概述

> 基于： [[1.1.1_protocol_requirements]] [[1.1.3.9_cognitive_trace_support]] [[1.1.3.11_textual_space_protocol]] [[1.1.3.10_cognitor_attributes]]

## 1. NPL 的本质：在 Textual Space 中创建和解释认知指令 (`CD`)

**核心定位**: NPL (Natural Pseudo Language) 是一种旨在创建结构化或半结构化文本**符号 (`Sign`)** 的系统，用于在 **ACP 文本空间 (`Textual Space`)** 中表达**认知指令 (`Cognitive Directive`, `CD`)**。这些 NPL `Sign` 为处理它们的 `Cognitor` 提供清晰的**约束 (`Constraint`)**，以精确地引导其内部的**符号过程 (Semiosis)**，使其形成的**解释项 (`Interpretant`)** 趋向于指令所意图的**对象 (`Object`)**。

NPL 通过以下两个核心要素实现这一目标：

1. **接近编程语言的结构化约束**: 利用一些在形式和功能上**接近**编程语言的结构元素（如用于表示关联、序列、命名、参数传递的标记和模式），为 NPL `Sign` 提供结构化的**外显再现体 (`Externalized Representamen`)**。这些结构化元素作为强力的**约束 (`Constraint`)**，辅助 `Cognitor` 解析和理解自然语言。
2. **自然语言定义 (NLD)**: 允许使用自然语言作为核心内容来定义认知任务或概念数据。这充分利用了 `Cognitor` 的自然语言理解能力，并将其与 NPL 的结构化接口相结合，使得 NPL `Sign` 中的自然语言部分成为需要被解释的核心**再现体 (`Representamen`)**。

这两种要素有机结合，使得 NPL 成为一个强大的工具，用于在 `Textual Space` 中创建既能利用自然语言表达丰富性，又能通过结构化形式提供必要精确性的 `CD`。NPL 的“执行”并非由一个独立的“运行时”完成，而是由**处理 NPL `Sign` 的 `Cognitor` 在其自身的认知过程中完成**，这个过程受到 NPL `Sign` 提供的约束的引导。

## 2. NPL 与 ACP Textual Space 的关系

- **NPL 是 Space 的语言**: NPL `Sign` 是在 `ACP Textual Space` 中创建和传递的主要信息载体之一。用户 (Human Cognitor) 或其他自动化 `Cognitor` 将 NPL 语句作为文本形式的**外显再现体**写入 `Space`。
- **Space 是 NPL 的上下文**: `Space` 中已有的所有文本（历史 NPL 语句、定义、CT 记录、其他 `Cognitor` 的输出等）构成了 `Cognitor` 处理当前 NPL `Sign` 时的重要上下文和**约束 (`Constraint`)** 来源。`Cognitor` 从 `Space` 中感知文本，进行符号过程，并将新的文本（包括 NPL 输出和 CT）追加回 `Space`。
- **NPL 驱动 Space 的演化**: `Cognitor` 对 NPL `Sign` 的处理及其产生的 CT 和结果，是推动 `Space` 内容和状态不断增长和演化的主要动力。
- **只可读取与添加的 Space 特性**: 采纳 Textual Space 的“只可读取与添加”特性意味着 NPL 对状态的修改和更新是通过在 `Space` 中**追加新的 NPL 语句或 CT**来表达的，而不是直接修改历史记录。NLD 机制需要理解这种追加式的状态演化模型。

## 3. NPL 的核心目标与哲学 (在 Textual Space 中)

1. **创建和传递 `CD`**: NPL 的首要目的是在 `Textual Space` 中创建并发布 `CD` (作为文本 `Sign`)，以指导其他 `Cognitor` 或自身后续的认知活动。
2. **引导认知过程**: `Cognitor` 在 `Textual Space` 中感知 NPL `Sign` 后，在其**内部认知流程**中对其进行处理。NPL 的结构和内容提供了必要的**约束**，引导 `Cognitor` 进行更精确、更符合预期的**符号过程 (Semiosis)**。
3. **管理概念性状态**: NPL 用于在 `Cognitor` 的认知范围内创建、配置和操作概念性对象或数据。这些概念性状态是 `Cognitor` 内部符号过程的一部分，其变化可以通过 NPL `CD` 进行描述，并通过 `CT` 进行记录。
4. **依赖 Cognitor 的原生能力**: NPL 的结构（包括接近编程语言的结构和 NLD）是为了辅助 `Cognitor` 天然具备的文本感知、自然语言理解、推理和符号过程能力。
5. **结果与过程外显化**: NPL `Sign` 引导的认知过程结果，通过特定的 NPL `CD` (如一个输出指令) 被**外显化**为新的文本 `Sign` 追加到 `Space` 中。同时，根据 ACP 核心协议和文本空间协议的要求，`Cognitor` **必须**通过文本形式的 **认知轨迹 (`CT`)** 记录其处理 NPL `Sign`（特别是 NLD 的解释和执行）的关键符号过程，将其追加到 `Space` 中。
6. **组织与复用**: NPL 可能包含机制（接近编程语言的模块或库概念）来组织相关的 NPL 语句和 NLD 定义，支持复用，进一步作为 `Cognitor` 处理时的结构化**约束**。

## 4. NPL 与符号学原理 (在 Textual Space 中)

- **NPL `Sign` = 带有结构约束和 NL 再现体的 `CD`**: 每个 NPL 语句或构造都是一个 `Sign`。其文本形式是**外显再现体**。这个再现体包含接近编程语言的结构化部分和核心的自然语言内容（尤其在 NLD 中）。
- **结构/接口 = 强 `Constraint`**: NPL 接近编程语言的结构、NLD 定义的参数和返回约束（例如从 TypeHint 借鉴的类型信息）提供了强烈的**约束 (`Constraint`)**，极大地限制了 `Cognitor` 对**对象 (`Object`)** 的可能解释空间，引导 `Semiosis` 向预期方向发展。
- **NL 定义内容 = 核心 Representamen**: NLD 定义中的自然语言主体是需要 `Cognitor` 运用其理解能力去解释的核心**再现体**。
- **目标 = 精确引导文本空间的 `Interpretant`**: NPL 的目标是减少 `Textual Space` 中 `Sign` 的歧义，使处理它的 `Cognitor` 形成的**解释项 (`Interpretant`)** 更符合 `CD` 的意图 (`Object`)，并最终体现在追加到 `Space` 中的新的文本 `Sign`（结果或 CT）中。
- **处理 NPL = 在 Cognitor 内部执行受约束的 Semiosis**: `Cognitor` 感知 `Space` 中的 NPL `Sign`，将其内化，并根据 NPL `Sign` 提供的文本结构和自然语言内容作为**约束**，在其内部认知流程中进行符号过程，管理相关的概念性 `Object`，并形成 `Interpretant`。
- **`CT` 记录过程 = 外显化的符号过程踪迹**: `Cognitor` **必须**通过文本形式的 `CT Sign`，详细记录其内部处理 NPL `CD` 的关键符号过程，特别是如何解释 NLD 的自然语言内容，如何应用结构约束和类型约束，以及如何管理概念性状态。这些 `CT` 被追加到 `Textual Space` 中，成为可追溯的、带有归属的符号过程踪迹。

## 5. 对实现能处理 NPL 的 Cognitor 的指导

实现一个能处理 NPL (包含 NLD) 的 `Cognitor`，意味着该 `Cognitor` 需要具备在其内部**有效处理 NPL 文本 Sign** 并以此**驱动自身认知活动**的能力：

1. **文本感知与解析**: 能够从 `Textual Space` 中感知并解析 NPL 文本 `Sign`，识别其结构和内容（包括接近编程语言的结构元素和自然语言部分）。
2. **内部状态管理**: 能够在其认知范围内管理与 NPL `Sign` 中提及的概念性 `Datum` 相关的内部状态或引用。
3. **理解结构约束**: 能够理解并利用 NPL 接近编程语言的结构元素（如用于命名、关联、序列的文本模式）作为**约束**来辅助符号过程。
4. **强大的自然语言理解**: **必须**具备强大的自然语言理解能力，以解释 NLD 定义中的自然语言主体，识别其意图和关联的 `Object`。
5. **应用 NLD 约束**: 能够将 NLD 定义提供的结构化接口、参数、以及从 TypeHint 等来源获取的类型信息作为**约束**，精确引导对 NLD 自然语言主体的解释，并确保 NLD “执行”的结果符合预期。
6. **驱动符号过程与模拟执行**: 能够基于对 NPL `CD` 的理解，驱动自身的符号过程，并在内部概念性地模拟执行 NPL 所描述的任务流程。
7. **与 Space 交互**: 能够根据 NPL 指令，将内部处理的结果**外显化**为新的文本 `Sign` 追加到 `Textual Space` 中。
8. **强制性 CT 记录**: **必须**详细记录其处理 NPL `Sign`（特别是 NLD 的解释、约束应用、推理过程）的关键符号过程，并将其以文本形式的 `CT Sign` 追加到 `Textual Space` 中。
9. **上下文敏感**: 能够有效利用 `Textual Space` 中的历史文本作为上下文和**约束**来指导当前的 NPL 处理。