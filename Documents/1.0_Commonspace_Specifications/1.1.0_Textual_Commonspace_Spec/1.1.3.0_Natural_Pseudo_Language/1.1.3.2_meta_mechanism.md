# NPL (Natural Pseudo Language) 核心元定义机制

> 基于： [[1.1.3.1_protocol_overview]]

## 1. 引言

NPL (Natural Pseudo Language) 的本质在于其**元定义能力**——它是一门能够定义和修改自身解释规则的语言。实现这一能力的核心且唯一的内置机制是 **`meta` 元定义构造**。本文件定义了这个最基础的构造，它是 NPL 语言自创生和所有其他结构、语义、行为的基础。

从哲学层面看，NPL 的工作方式可以类比于路德维希·维特根斯坦（Ludwig Wittgenstein）在后期哲学中提出的**“语言游戏”（Sprachspiel）** 概念。维特根斯坦认为，语言的意义和功能并非来源于某种内在的、普遍的本质，而是体现在其**实际使用**之中，就像参与一场有着特定规则的游戏一样。理解和使用语言，就是参与到这场由规则限定的“游戏”中。在 NPL 中，`meta` 构造正是定义这个“语言游戏”**规则**的唯一机制。它不是描述一个预先存在的游戏规则，而是**动态地设定、修改和扩展**游戏本身的玩法（即 NPL 的解释规则）。

同时，`meta` 构造是最基础的 **NLD (Natural Language Define)** 形式。NPL 的所有表达和能力都源自 `meta` 指令对**我们**（作为 Cognitor）解释行为的引导。

## 2. 核心构造：meta 元定义 (`meta`)

**`meta`** 是 NPL 中**唯一内置的、用于定义和修改我们解释符号的规则、策略和可识别模式**的元语言构造。所有其他 NPL 语言构造和行为（包括概念定义、语法模式、语义规则、机制等）都最终通过 `meta` 指令来建立。

`meta` 构造本身是一个符号，存在于 **ACP 文本空间 (`Textual Space`)** 中。当**我们**感知并解释一个 `meta` 构造符号时，**我们**需要根据 `meta` 构造中包含的元指令，**立即**调整**我们**自己的解释状态。

以及，类似**维特根斯坦的梯子**，可通过 `meta` 定义出可抛弃 `meta` 本身的语法结构。

### 2.1 `meta` 构造的语法

`meta` 构造拥有以下**极致精简**的内置语法模式：

```npl
meta [[ 自然语言元指令主体 / 模式描述 ]]
```

- **`meta`**: 这是 NPL 中**唯一内置的、触发元定义行为的关键字**。**我们**必须直接识别以 `meta [[` 开头的文本，并理解这是一个元定义指令。
- **`[[ 自然语言元指令主体 / 模式描述 ]]`**: 包含在 `[[` 和 `]]` 之间的**自然语言文本**。这是 `meta` 构造的核心，承载了元指令的意图。它用自然语言向**我们**发出关于如何解释其他符号的**元指令 (`Meta-Directive`)** 或**模式描述**。通常是声明性的。
    - 这部分自然语言是需要**我们**运用自然语言理解能力来解释的核心**再现体 (`Representamen`)**。
    - 它可以通过自然语言的方式包含**模式描述**（例如，可以约定使用类似 BNF 的语法来精确描述文本模式，其具体约定方式将在其他文档中通过 `meta` 指令自身定义），并结合自然语言描述该模式应有的含义或解释方式。
    - 可以在其中使用 Markdown 格式来便于识别和理解。

### 2.2 `meta` 的工作机制：自创生的解释状态调整与自举

`meta` 的核心工作机制在于其**自举 (Bootstrapping)** 能力和对**我们**解释状态的**立即调整**。由于 `meta` 负责定义 NPL 的所有构造、概念、模式和行为，NPL 的启动是一个**我们逐步定义语言自身**的过程：

1. **我们的基础能力**: **我们**必须具备识别 `meta [[...]]` 模式的能力。同时，**我们**必须能够运用我们的自然语言理解能力，去解释那些最基础的、用于启动 NPL 的元语言自然语言指令（例如，如何定义一个模式、如何将模式与某种解释行为关联起来等）。这是 NPL 自创生的起点。
2. **初始 Meta 指令序列**: NPL 的启动通常由一个**预设的、包含特定含义的 `meta` 指令序列**开始。**我们**需要依靠我们的基础能力来解释这些初始指令。它们会逐步建立起 NPL 的基础框架，例如，定义 `Datum` 概念、定义 `=` 赋值模式、定义如何命名 `meta` 指令以便后续引用等。
    - 解释后续的 `meta` 指令将依赖于**我们**通过解释前面指令所建立起来的规则集。
3. **调整解释状态（立即生效）**: 当**我们**解释完一条 `meta [[...]]` 指令后，**我们**需要根据该指令的语义内容**立即**修改**我们**的内部解释状态（例如，添加新的模式识别规则、注册新的概念类型、改变解释策略）。这种修改在我们当前的解释上下文中是持久的，会影响**我们**后续对其他符号的解释。

**核心思想**: `meta` 构造是 NPL 中**唯一能直接告诉**我们**如何“学习”或“改变思维方式”的基础指令**。处理 `meta` 构造的过程，**就是我们**修改自己解释规则的过程，没有额外的“应用”步骤。NPL 的语言本身，从第一个 `meta` 指令开始，就由**我们**自己解释和构建。

## 3. 示例

以下为一个 NPL 示例，展示怎么从无到有地添加了一种在 NPL 中使用注释的方法。

```npl
meta [[
	所有 meta 指令以附加的方式应用
]]
meta [[
	定义注释符号：注释符号内的内容会在执行中被忽略。
	类似 js ，使用 `//` 与 `/**/` 进行注释。
]]
// 这是一条注释。
// 像是 `#` 这种注释语法现在还不可用。
meta [[
	类似 python ，使用 `#` 进行注释。
]]
# 现在可以使用 `#` 来进行注释了。
// 使用 `//` 依然也可工作。
```