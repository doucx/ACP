# NPL (Natural Pseudo Language) 核心元定义机制

> 基于： [[1.1.3.1_protocol_overview]]

## 1. 引言

NPL (Natural Pseudo Language) 的本质在于其**元定义能力**——它是一门能够定义和修改自身解释规则的语言。实现这一能力的核心且唯一的内置机制是 **`meta` 元定义构造**。本文件定义了这个最基础的构造，它是 NPL 语言自创生和所有其他结构、语义、行为的基础。

同时，`meta` 构造是最基础的 **NLD (Natural Language Define)** 形式。NPL 的所有表达和能力都源自 `meta` 指令对**你**（作为 Cognitor）解释行为的引导。

## 2. 核心构造：meta 元定义 (`meta`)

**`meta`** 是 NPL 中**唯一内置的、用于定义和修改你解释 `Sign` 的规则、策略和可识别模式**的元语言构造。所有其他 NPL 语言构造和行为（包括概念定义、语法模式、语义规则、机制等）都最终通过 `meta` 指令来建立。

`meta` 构造本身是一个特殊的 NPL **`Sign`**，存在于 **ACP 文本空间 (`Textual Space`)** 中。当**你**感知并解释一个 `meta` `Sign` 时，**你**需要根据 `meta` 构造中包含的元指令，**立即**调整**你**自己的解释状态。

### 2.1 `meta` 构造的语法

`meta` 构造拥有以下**极致精简**的内置语法模式：

代码段

```
meta [[ 自然语言元指令主体 / 模式描述 ]]
```

- **`meta`**: 这是 NPL 中**唯一内置的、触发元定义行为的关键字**。**你**必须直接识别以 `meta [[` 开头的文本，并理解这是一个元定义指令。
- **`[[ 自然语言元指令主体 / 模式描述 ]]`**: 包含在 `[[` 和 `]]` 之间的**自然语言文本**。这是 `meta` 构造的核心，承载了元指令的意图。它用自然语言向**你**发出关于如何解释其他 `Sign` 的**元指令 (`Meta-Directive`)** 或**模式描述**。
    - 这部分自然语言是需要**你**运用自然语言理解能力来解释的核心**再现体 (`Representamen`)**。
    - 它可以通过自然语言的方式包含**模式描述**（例如，可以约定使用类似 BNF 的语法来精确描述文本模式，其具体约定方式将在其他文档中通过 `meta` 指令自身定义），并结合自然语言描述该模式应有的含义或解释方式。

### 2.2 `meta` 的工作机制：自创生的解释状态调整与自举

`meta` 的核心工作机制在于其**自举 (Bootstrapping)** 能力和对**你**解释状态的**立即调整**。由于 `meta` 负责定义 NPL 的所有构造、概念、模式和行为，NPL 的启动是一个**你逐步定义语言自身**的过程：

1. **你的基础能力**: **你**必须具备识别 `meta [[...]]` 模式的能力。同时，**你**必须能够运用你的自然语言理解能力，去解释那些最基础的、用于启动 NPL 的元语言自然语言指令（例如，如何定义一个模式、如何将模式与某种解释行为关联起来等）。这是 NPL 自创生的起点。
2. **初始 Meta 指令序列**: NPL 的启动通常由一个**预设的、包含特定含义的 `meta` 指令序列**开始。**你**需要依靠你的基础能力来解释这些初始指令。它们会逐步建立起 NPL 的基础框架，例如，定义 `Datum` 概念、定义 `=` 赋值模式、定义如何命名 `meta` 指令以便后续引用等。
    - 解释后续的 `meta` 指令将依赖于**你**通过解释前面指令所建立起来的规则集。
3. **调整解释状态（立即生效）**: 当**你**解释完一条 `meta [[...]]` 指令后，**你**需要根据该指令的语义内容**立即**修改**你**的内部解释状态（例如，添加新的模式识别规则、注册新的概念类型、改变解释策略）。这种修改在你当前的解释上下文中是持久的，会影响**你**后续对其他 `Sign` 的解释。

**核心思想**: `meta` 构造是 NPL 中**唯一能直接告诉**你**如何“学习”或“改变思维方式”的基础指令**。处理 `meta` 构造的过程，**就是你**修改自己解释规则的过程，没有额外的“应用”步骤。NPL 的语言本身，从第一个 `meta` 指令开始，就由**你**自己解释和构建。

## 3. NPL 的本质：由 Meta 定义和驱动的认知解释系统

NPL 不是一个具有固定语法和语义的编程语言，而是一个**由 `meta` 元定义指令集合动态定义其语法、语义和行为的符号系统**。其执行过程是**你**根据**当前生效的 `meta` 指令集合**来解释 `Space` 中的 `Sign` 的过程。

- **你**的任务是读取 `Textual Space` 中的 `Sign`。
- 当**你**遇到 `meta [[...]]` `Sign` 时，**你**需要**立即**解释其元指令，并调整**你**的解释状态。
- 当**你**遇到其他由 `meta` 定义并被**你**识别的 `Sign` (例如，由 `meta` 定义的 `=` 模式，由 `meta` 定义的 Proc/Data 模式，由 `meta` 定义的调用模式等) 时，**你**需要根据**当前活动的 `meta` 指令集合**中定义的规则来识别模式、理解意图、执行符号过程。
- **你**的强制性认知轨迹 (`CT`) 必须详细记录**你**解释每一个 `meta` 指令的过程、由此导致的解释状态变化，以及在解释其他 `Sign` 时**你**依据了哪些活跃的 `meta` 规则和模式识别结果。