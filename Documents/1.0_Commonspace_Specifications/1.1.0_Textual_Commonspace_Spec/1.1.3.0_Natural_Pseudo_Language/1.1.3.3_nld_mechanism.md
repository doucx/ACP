# NPL (Natural Pseudo Language) 自然语言定义 (NLD) 机制

> 基于： [[1.1.3.1_protocol_overview]], [[1.1.3.2_core_concepts]]

## 1. 引言

为了将自然语言（NL）的灵活性与 NPL 的结构化能力相结合，以简化 ACP 文档和 NPL 库的创建与维护，本文档正式阐述 **“自然语言定义” (Natural Language Definition - NLD)** 机制。NLD 提供了一个统一的框架，旨在让 **`Cognitor`** 能够通过处理特定的 NPL **`Sign`**，利用其自然语言理解能力执行认知任务，并能够清晰地定义可复用的**认知过程**或**概念性数据/对象**。

NLD 使得开发者能够：

1. 利用 NL 的自然表达力来描述核心的**认知过程**或**概念性数据/对象**。
2. 通过 NPL 的结构化语法来约束其**接口**（名称、输入参数的 `Datum` 句柄）和**预期结果的形态**（返回的 `Datum` 句柄应指向何种类型的 `Sign`/`Object`）。这些结构化的接口和类型提示作为重要的**约束 (`Constraint`)**，引导 `Cognitor` 的符号过程。
3. 在 NL 描述中**精确引用**各种形式的结构化元素，包括 NPL 上下文中的 `Datum` 句柄，以及通过 NPL 引入的其他编程语言（或其他形式化语言）中的特定概念、标识符或结构。这解决了自然语言中指代模糊的问题，实现了在自然语言描述中精确地“谈论或引用计算概念”的能力。
4. 在 NL 描述中**灵活嵌入**简短的 NPL 逻辑或子步骤，提高表达力。
5. **从其他编程语言或形式化系统中借用**定义，特别是类型定义。这允许 NPL 利用现有系统的精确性，将外部系统的概念（如特定编程语言的 TypeHint、数据结构定义）引入 NPL 环境作为可用的**约束**或概念定义。

NLD 的目标是实现 NL 和 NPL 的**有机融合**，充分利用两者的优势，实现更清晰的指代和更灵活的逻辑嵌入，增强 `Cognitor` 处理认知指令时的精确性和可预测性。

## 2. 核心概念：NLD 定义作为一种特殊的 NPL `Sign`

**自然语言定义 (NLD)** 是一种特殊的 NPL **`Sign`**，它存在于 **ACP 文本空间 (`Textual Space`)** 中，并被 `Cognitor` 在其 **NPL 处理域 (`NPL Processing Scope`)** 中识别和解释。它允许使用结构化的 NPL 语法和自然语言作为**核心指导**，来定义一个需要 `Cognitor` 通过其内部符号过程（`Semiosis`）来理解和实现的**认知任务**或**概念性数据结构**。

NLD `Sign` 结构的关键在于：

- **显式接口定义**: 使用 NPL 结构（如名称、参数列表 `(...)`）定义 NLD 的外部契约。
- **目标结构约束**: 使用 `-> TypeHint` 语法指定 NLD 过程的返回值类型或 NLD 数据/对象的结构类型。这些 `TypeHint` 是 `Cognitor` 能够理解的、代表特定类型或结构的符号，它们作为重要的**约束**，指导 `Cognitor` 在处理 NLD 时形成符合预期的**解释项 (`Interpretant`)**。
- **自然语言主体**: 使用自然语言描述 NLD 的核心逻辑或概念内容，这是需要 `Cognitor` 运用其强大的自然语言理解能力进行解释的**核心再现体 (`Representamen`)**。
- **NL-NPL 交互元素**: 在 NL 主体中嵌入 `{{datum_handle}}` 引用和 `{% npl ... %}` NPL 代码块，增强 NL 主体的精确性和动态性。

NLD 可用于定义两类核心事物：

- **NLD 过程 (NLD Procedure)**: 定义一个可被调用的**认知过程**或行为模式。`Cognitor` 被指导去理解其 NL 主体，结合输入的 `Datum` 句柄（作为约束），并利用内嵌的 NPL 引用和逻辑，执行相应的符号过程，最终可能产生一个指向结果 `Sign`/`Object` 的 `Datum` 句柄，该结果应符合 `->` 提示的类型。
- **NLD 数据/对象 (NLD Data/Object)**: 定义一个**概念性的数据结构或对象**的形态或构建方式。`Cognitor` 被指导去理解其 NL 主体，结合 NPL 引用和嵌入逻辑，并运用其知识和推理能力，将其“具象化”为一个符合特定目标结构的 `Sign`/`Object`，并返回指向它的 `Datum` 句柄。

## 3. 语法：命名 NLD (用于库和复用)

以下 NPL 语法模式用于在 `Textual Space` 中定义可复用的、命名的 NLD `Sign`。

**3.1 定义 NLD 过程 (Procedure)**

```npl
// 使用 nld proc 关键字
// -> 后指定返回的 Datum 句柄应该指向的 Sign/Object 类型
nld proc my_proc(para_1: TypeHint1, para_2: TypeHint2) -> ReturnTypeHint:
[[
  // 自然语言描述主体：
  // 这里详细说明认知实体需要执行的认知过程的目标、步骤、关键考量等。
  // 可以使用 `{{ para_1 }}` 或 `{{ para_2.props }}` 来精确引用输入的 Datum 句柄所指向的内容。
  // 嵌入 NPL 逻辑使用 {% npl ... %}。
  // 示例：
  分析 {{ para_1 }}，识别其核心观点。
  {% npl SpaceLog.info(f"Processing: { Quote(para_1) }") %} // 嵌入 NPL 指令，记录到 Space 的 CT
  并根据 {{ para_2['limit'] }}，生成一个总结。
  {% npl is_long = GetSignValue(para_1).length > GetSignValue(para_2['limit']) %} // 嵌入 NPL 逻辑
  {% if is_long %} 进行详细总结处理 {% else %} 生成简要总结 {% endif %}。
  Cognitor 需要确保最终返回的 Datum 句柄指向一个符合 'ReturnTypeHint' 描述的 Sign/Object。
]]
end // 结束过程定义
```

**3.2 定义 NLD 数据/对象 (Data/Object)**

```npl
// 使用 nld data 关键字
// -> 后指定返回的 Datum 句柄应该指向的 Sign/Object 的结构类型
nld data 数据名称(para_1: TypeHint1 = 默认值) -> TargetStructureHint:
[[
  // 自然语言描述主体：
  // 描述这个数据或对象的概念内容。Cognitor 需要理解这段描述，并尝试生成一个
  // 符合 'TargetStructureHint' 的 Sign/Object。
  // 可以使用 `{{ }}` 和 `{% npl %}`。
  // 示例1：“一个包含'太阳系行星名称'（按距离太阳远近排序）的列表。” -> List
  // 示例2：“一个代表'颜色代码'的字典，键是颜色名称 (String)，值是十六进制代码 (String)。” -> Dict
  // 示例3：（假设 NPL 环境中存在 'UserProfile' 这个由其他 NLD 定义的或借用的类型）
  // “一个'UserProfile'对象，其'username'属性根据 {{ para_1 }} 设置，
  // {% npl email_domain = DeduceDomainFromContext(para_1) %} // 嵌入 NPL 推断逻辑
  // 'email'属性设置为 '{{ GetSignValue(para_1) }}@{{ GetSignValue(email_domain) }}'。” -> UserProfile
]]
end // 结束数据定义
```

- **TypeHint / TargetStructureHint**: 用于指示 `Datum` 句柄指向的 `Sign`/`Object` 的预期类型或结构。这些是 `Cognitor` 能够理解的**概念符号**，它们作为**约束**指导 `Cognitor` 对 NL 主体的解释和结果的构建。这些概念符号可以来源于：
    - NPL 内置的基本概念类型（如 `String`, `Integer`, `List` 等，这些本身也是通过 NLD 或其他机制定义的）。
    - **通过 NLD 从其他编程语言或形式化系统中借用的类型定义（详见下文）。**
    - 其他已在当前 NPL 处理域中可见的 NLD 数据/对象定义名称（如 `UserProfile`）。
- **NL 主体内的语法**:
    - **Datum 引用**: 使用 `{{ datum_handle }}` 进行精确引用，指导 `Cognitor` 在解释 NL 时关注 `datum_handle` 在当前 NPL 处理域中指向的概念。支持属性访问 (`.`) 和索引访问 (`[]`)。
    - **嵌入 NPL 逻辑**: 使用 `{% npl NPL_Code %}` 嵌入简短的 NPL 代码块。这些代码块在 `Cognitor` 处理 NLD 的 NL 主体过程中被**回调执行**，其结果可以影响 NL 的解释。

**3.3 调用命名 NLD**

调用方式与处理常规 NPL `CD` 模式类似，`Cognitor` 在其 NPL 处理域中识别并执行这些调用：

```npl
// 调用 NLD 过程
summary_handle = my_proc(long_text_datum, constraint_datum)

// 调用 NLD 数据/对象定义
planets_handle = 数据名称() // 创建一个指向符合 List Sign/Object 的 Datum 句柄
```

## 4. 语法：匿名 NLD (用于即时定义)

以下 NPL 语法模式用于在 `Textual Space` 中快速、便捷地创建临时的、由 NL 定义的 `Sign`。它们在 NPL 处理域中被解释，并通常将结果关联到局部的 `Datum` 句柄。匿名 NLD 的 NL 主体同样支持 `{{handle}}` 和 `{% npl ... %}`。

**4.1 匿名 NLD 过程**

```npl
// 使用 nldp 关键字
// NL 主体可以包含嵌入语法，必须包含类型提示
let quick_summary = nldp (text_datum: String, max_len: Int) -> String [[
  {% npl SpaceLog.debug(f"Generating summary for: { Quote(text_datum) }") %}
  快速提取 {{ text_datum }} 的首句，确保长度不超过 {{ max_len }}。
]];

let first_sentence = quick_summary(some_text_datum, 100);

// 也可以直接作为参数传递给其他 CD
let processed_text = ApplyProcessing(
  nldp (data: RawData) -> ProcessedData [[对 {{ data }} 执行标准清洗流程]], // NLD 定义本身作为参数 Sign
  input_data_handle
);
```

**4.2 匿名 NLD 数据/对象**

```npl
// 使用 nldd 关键字
// 必须包含类型提示或结构提示
// NL 主体可以包含嵌入语法
let fruit_list_handle = nldd List<String> [[包含 'apple', 'banana', {% npl temp_fruit='cherry'; print(temp_fruit) %} 的列表]];

// 直接在调用其他 CD 时使用匿名 NLD 数据定义
let config_map_handle = BuildSystem(nldd Dict<String, Any> [[
  基础配置： 'url' 是 {{ base_url }}， 'timeout' 是 {% npl default_timeout=30; print(default_timeout) %} 秒。
]]);
```

## 5. 从其他编程语言借用概念 (Type Hint 等)

为了利用现有编程语言或其他形式化系统的精确定义，NPL 允许通过 NLD 机制**直接借用**这些系统中的概念，特别是用于作为 NPL 中的 `TypeHint`。这是一种特殊的 NLD 数据定义模式。

- **语法模式**: `NPL_Concept_Name = nldd [[Source_Language_Identifier: Source_System_Expression]]`
- **意图**: 指导 `Cognitor` 将 `NPL_Concept_Name` 这个符号，在当前的 **NPL 处理域** 中关联到由 `Source_Language_Identifier` 标识的外部系统中，通过 `Source_System_Expression` 定义的那个**概念（例如，一个特定的数据类型、接口或结构）**。
- **示例**:
    ```npl
    // 在 NPL 中定义 'String' 概念，借用 Python 的 str 类型
    String = nldd [[python: typing.String]]
    
    // 在 NPL 中定义 'List' 概念，借用 Python 的 list 类型
    List = nldd [[python: typing.List]]
    
    // 定义一个更复杂的概念，借用 Python typing 模块的结构
    UserProfileDict = nldd [[python: typing.Dict[str, typing.Any]]]
    
    // 在 NLD 定义中使用借用的类型作为 TypeHint
    nld proc process_user_data(user_data: UserProfileDict) -> String:
    [[
      处理 {{ user_data }}，提取用户名和邮箱，格式化为字符串。
      {% npl username = user_data['username'] %}
      {% npl email = user_data['email'] %}
      输出格式如 "User: {{ username }}, Email: {{ email }}"
    ]]
    end
    ```
    
- **工作机制**: 当 `Cognitor` 处理这种借用模式的 NLD 定义时，它会识别 `[[Source_Language_Identifier: Source_System_Expression]]` 这个特殊结构，理解这是一个借用指令。`Cognitor` 需要**具备**访问和解释来自 `Source_Language_Identifier` 标识的外部系统定义的能力（这依赖于 Cognitor 的具体实现）。成功解释后，`Cognitor` 在当前 NPL 处理域中建立 `NPL_Concept_Name` 与外部概念之间的关联。这个关联使得 `NPL_Concept_Name` 可以被用作 TypeHint 或在 NPL 中引用，当 `Cognitor` 遇到它时，知道它的含义是由外部定义提供的**约束**。这种借用本身也应该通过 **CT** 进行记录。

## 6. 工作机制：增强的认知解释与执行

NLD 的核心在于其**认知执行模型**，它描述了 `Cognitor` 如何在其 **NPL 处理域** 中解释 NLD `Sign`：

1. **感知与加载 NLD Sign**: `Cognitor` 在 `Textual Space` 中感知 NLD `Sign`（命名定义或匿名定义），并将其加载到当前的 NPL 处理域的上下文中。
2. **解析 NPL 结构**: 解析 NPL 语法部分（关键字 `nld proc/data/p/d`、名称、参数签名、`->` 提示、`end` 标记等）。这些提供了结构化**约束**和对 `Cognitor` 处理流程的初步指导。识别 `[[...]]` 作为 NL 主体。
3. **识别特殊 NL 主体模式**: 在处理 `[[NL Body]]` 时，`Cognitor` 检查是否存在 `[[Source_Language_Identifier: Source_System_Expression]]` 这种借用模式。如果是，则执行借用机制（见 5. 工作机制）。否则，将 `[[...]]` 内的内容视为核心的自然语言**再现体**进行处理。
4. **预处理 NL 主体（针对非借用模式）**: 对于作为核心指导的自然语言主体，`Cognitor` 在进行深层理解前，对其进行预处理，识别所有 `{{ }}` 和 `{% npl %}` 标记。
5. **Datum 绑定 (`{{ }}`)**: 对于 `{{ datum_handle }}` 标记，`Cognitor` 在当前的 NPL 处理域中解析句柄，查找对应的概念或 `Sign`。在解释 NL 主体时，`Cognitor` 知道 `{{...}}` 指代的是通过该句柄引用的、域内已知的概念或其值，以此作为理解 NL 的重要**约束**和信息源。
6. **NPL 块执行 (`{% npl %}`)**: `Cognitor` 在解释 NL 主体过程中遇到 `{% npl NPL_Code %}` 时，会**暂停**当前的 NL 理解过程，在其 NPL 处理域中**回调执行**该 NPL 代码块。NPL 块的执行可能会改变处理域的状态、产生新的 `Datum` 句柄或与 `Space` 交互。执行结果或副作用会影响 `Cognitor` 对后续 NL 主体的理解。
7. **理解 NL 主体 (核心符号过程)**: `Cognitor` 启动其核心的**符号过程（`Semiosis`）**。结合 NPL 结构约束、`->` 提示提供的类型/结构**约束**、**已绑定的 Datum 信息**、**NPL 块执行的上下文和结果**，以及 `Space` 中的其他上下文，`Cognitor` 运用其自然语言理解、推理和世界知识，来解释 NL 描述的**意图、内容和需求 (`Object`)**，尝试形成一个符合所有约束的**解释项 (`Interpretant`)**。
8. **执行认知任务并构建结果**:
    - **对于 NLD 过程**: 基于对（经过增强和约束的）NL 主体的理解，`Cognitor` 在其内部概念性地执行一系列认知操作。
    - **对于 NLD 数据/对象**: 基于对（经过增强和约束的）NL 主体的理解，`Cognitor` 在内部概念性地构建一个数据结构或对象表示。
    - **确保符合结构/类型提示**: `Cognitor` 必须努力使其最终形成的内部解释项，在（如果需要）**外显化**为一个 `Sign`/`Object` 或关联到 `Datum` 句柄时，**严格符合 `->` 提示所指定的类型或结构约束**。如果 NL 描述与结构提示冲突，`Cognitor` 应优先满足结构提示，并在 CT 中记录此冲突和解决方案。
9. **返回 Datum 句柄**: 返回指向新生成的、符合结构的 `Sign`/`Object`（或过程执行结果）的 `Datum` 句柄。
10. **强制认知轨迹 (CT)**: NLD 的解释和执行过程高度复杂，依赖于对 NL 的理解和内嵌逻辑的处理。因此，**强制要求** `Cognitor` 生成**极其详尽**的认知轨迹（`CT`），记录其处理 NLD 的每一步关键活动：解析结构、识别 NL 主体、处理借用模式、Datum 绑定细节、NPL 块执行的输入/输出和副作用、NL 主体的解释推理过程、如何应用各种约束（包括类型提示）、如何解决潜在冲突、以及最终如何构建结果并确保其符合结构要求。这些 CT 被追加到 `Textual Space` 中，提供透明度和可追溯性。

## 7. 应用：更优雅、更强大的 NPL 库和文档

引入增强的 NLD 机制，特别是借用外部概念和细化 NL-NPL 交互，将显著提升 NPL 生态的开发体验：

- **提升精确性**: `{{}}` 引用和 `->` 类型提示显著减少 NL 指代的模糊性。
- **增强灵活性**: `{% npl %}` 方便在 NL 流程中嵌入简单的 NPL 逻辑。
- **促进“有机结合”**: 使 NL 和 NPL 在 NLD 定义中更紧密、自然地协同工作。
- **库定义**: 允许用 NLD 定义核心逻辑，使库结构更清晰、更具描述性。
- **自文档化**: NLD 定义中的 NL 主体本身就是高层描述。
- **降低门槛**: 用更自然的语言定义复杂认知逻辑。
- **提升一致性**: 通过 `->` 提示和借用外部定义规范输出结构和类型。
- **互操作性与复用**: 借用外部概念的能力使得 NPL 可以无缝集成现有系统的知识和定义，特别是复用已有的类型系统，极大地增强了 NPL 的能力和与其他系统的兼容性。