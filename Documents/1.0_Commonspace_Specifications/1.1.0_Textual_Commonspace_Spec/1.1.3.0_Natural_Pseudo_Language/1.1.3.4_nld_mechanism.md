# NPL 自然语言定义 (NLD) 机制

> 基于： [[1.1.3.1_protocol_overview]], [[1.1.3.2_core_concepts]]

## 1. 引言

为了将自然语言（NL）的灵活性与 NPL 的结构化能力相结合，以简化 ACP 文档和 NPL 库的创建与维护，本文档正式提出 **“自然语言定义” (Natural Language Definition - NLD)** 机制。NLD 提供了一个统一的框架，旨在让开发者能够：

1. 利用 NL 的自然表达力来描述核心的**认知过程**或**概念性数据/对象**。
2. 通过 NPL 的结构化语法来约束其**接口**（名称、输入参数 `Datum` 句柄）和**预期结果的形态**（返回的 `Datum` 句柄应指向何种类型的 `Sign`/`Object`）。
3. 在 NL 描述中**精确引用**各种形式的结构化元素，包括但不限于 NPL 上下文中的 `Datum` 句柄，以及其他编程语言（或其他形式化语言）中的特定代码片段、函数名、变量名或数据结构等标识符，解决指代模糊问题，实现“用自然语言谈论或引用编程语言”的能力。
4. 在 NL 描述中**灵活嵌入** NPL 逻辑或子步骤，提高表达力。
5. 利用 NLD 的结构化框架和引用机制，甚至可以对其他编程语言自身的语法、语义和核心概念进行描述和模拟。这意味着编程语言本身也可以被视为一种特殊的“定义对象”，通过 NLD 机制将其结构化能力和逻辑表达方式融入 NLD 体系，为跨语言的概念整合和互操作提供可能。

NLD 的目标是实现 NL 和 NPL 的**有机融合**，充分利用两者的优势，实现更清晰的指代和更灵活的逻辑嵌入。

## 2. 核心概念：NLD

**自然语言定义 (NLD)** 是一种 NPL 构造，它允许使用自然语言作为**核心指导**，来定义一个需要认知实体（`Cognitor`）通过其内部符号过程（`Semiosis`）来理解和实现的**认知任务**或**概念性数据结构**。其关键在于，NL 的灵活性通过 NPL 的**显式接口定义**、**目标结构约束**以及**新增的 NL-NPL 交互语法**得到规整和增强。

NLD 可用于定义两类核心事物：

- **NLD 过程 (NLD Procedure)**: 封装一个**认知过程**或行为。认知实体被指导去理解 NL 描述（主体），结合输入的 `Datum`（作为约束），并利用内嵌的 NPL 引用 (`{{handle}}`) 和逻辑 (`{% npl ... %}`)，执行相应的符号过程，最终可能产生一个指向结果 `Sign`/`Object` 的 `Datum` 句柄。
- **NLD 数据/对象 (NLD Data/Object)**: 利用 NL 来描述一个**概念性的数据结构或对象**。认知实体被指导去理解 NL 描述，结合 NPL 引用和嵌入逻辑，并运用其知识和推理能力，将其“具象化”为一个符合特定目标结构的 `Sign`/`Object`，并返回指向它的 `Datum` 句柄。

## 3. 语法：命名 NLD (用于库和复用)

为了保证 NPL 库定义的可读性和结构性，引入以下 NPL 关键字来定义可复用的、命名的 NLD。

**3.1 定义 NLD 过程 (Procedure)**

```npl
// 使用 nld proc 关键字
// -> 后指定返回的 Datum 应该指向的 Sign/Object 类型
nld proc my_proc(para_1: TypeHint1, para_2: TypeHint2) -> ReturnTypeHint:
[[
  // [必需] 自然语言描述主体：
  // 这里详细说明认知实体需要执行的认知过程的目标、步骤、关键考量等。
  // 可以使用 `{{ para_1 }}` 或 `{{ para_2.props }}` 来精确引用输入的 Datum 句柄所指向的内容。
  // 示例：
  分析 {{ para_1 }} ，识别其核心观点。
  {% npl SpaceLog.info(f"开始分析: { Quote(para_1) }") %} // 嵌入 NPL 日志记录
  并根据 {{ para_2['limit'] }} ，生成一个总结。
  {% npl is_long = len(para_1) > para_2['limit'] %} // 嵌入 NPL 逻辑判断
  {% if is_long %} 进行相应处理 {% else %} 继续 {% endif %}。
  认知实体需要确保返回的 Datum 指向一个符合 'ReturnTypeHint' 描述的 Sign/Object。
]]
end // 结束过程定义
````

**3.2 定义 NLD 数据/对象 (Data/Object)**

```npl
// 使用 nld data 关键字
// -> 后指定返回的 Datum 应该指向的 Sign/Object 的结构类型
nld data 数据名称(para_1: TypeHint1 = 默认值) -> TargetStructureHint:
[[
  [必需] 自然语言描述主体：
  描述这个数据或对象的概念内容。认知实体需要理解这段描述，并生成一个
  符合 'TargetStructureHint' 的 Sign/Object。
  示例1：“一个包含'太阳系行星名称'（按距离太阳远近排序）的列表。” -> List
  示例2：“一个代表'颜色代码'的字典，键是颜色名称（字符串），值是十六进制代码（字符串）。” -> Dict
  示例3：（假设存在 NPL 类 'UserProfile'）“一个'UserProfile'对象，其'username'属性根据 {{ para_1 }} 设置，
  {% npl email_domain = deduce_domain_from_context(para_1) %} // 嵌入 NPL 推断逻辑
  'email'属性设置为 '{{ para_1 }}@{{ email_domain }}'。” -> UserProfile
]]
end // 结束数据定义
```

- **TypeHint / TargetStructureHint**: 用于指示 `Datum` 句柄指向的 `Sign`/`Object` 的预期类型或结构。可以是：
    - 基本概念类型：`String`, `Integer`, `Boolean`, `Float`
    - 集合概念类型：`List`, `Set`, `Dict` (或 `Map`)
    - 已在 NPL 环境中定义的类名：`UserProfile`, `CanvasNode` 等。
- **NL 主体内的语法**:
    - **Datum 引用**: 使用 `{{ datum_handle }}` 进行精确引用，支持属性访问 (`.`) 和索引访问 (`[]`)。
    - **嵌入 NPL 逻辑**: 使用 `{% npl NPL_Code %}` 嵌入简短的 NPL 代码块。

**3.3 调用命名 NLD**

调用方式与普通 NPL 函数/方法类似：

```npl
// 调用 NLD 过程
summary_handle = SummarizeText(long_text_datum, constraint_datum)

// 调用 NLD 数据/对象定义
planets_handle = SolarSystemPlanets() // -> 指向一个 List Sign/Object
color_codes_handle = ColorCodeMap()   // -> 指向一个 Dict Sign/Object
```

## 4. 语法：匿名 NLD (用于即时定义)

为了在 NPL 代码中快速、便捷地使用由 NL 定义的过程或数据，提供匿名 NLD 语法。匿名 NLD 的 NL 主体同样支持 `{{handle}}` 和 `{% npl ... %}`。

**4.1 匿名 NLD 过程**

```npl
// 使用 nldp 关键字
// NL 主体可以包含嵌入语法
quick_summary = nldp (text_datum: String, max_len: Int) -> String [[
  {% npl SpaceLog.debug(f"正在为 { Quote(text_datum) } 生成摘要...") %}
  快速提取 {{ text_datum }} 的首句，确保长度不超过 {{ max_len }}。
]]

first_sentence = quick_summary(some_text_datum, 100)

// 也可以直接作为参数传递
processed_text = ApplyProcessing(
  nldp (data: RawData) -> ProcessedData [[对 {{ data }} 执行标准清洗流程]], // 示例引用
  input_data_handle
)
```

**4.2 匿名 NLD 数据/对象**

```npl
// 使用 nldd 关键字
// 必须包含类型提示
// NL 主体可以包含嵌入语法
fruit_list_handle = nldd List [[包含 'apple', 'banana', {% npl fruit='cherry'; print(fruit) %} 的列表]]

// 直接在调用中使用
config_map = BuildSystem(nldd Dict [[
  基础配置： 'url' 是 {{ base_url }}， 'timeout' 是 {% npl default_timeout=30; default_timeout %} 秒。
]])
```

## 5. 结构/类型提示语法

推荐在 NLD 定义本身中使用 `-> TypeHint` 作为标准方式，来指定其契约。同时，可以提供一个显式的 `NLD.interpret_as(nl_datum_handle, target_type=<TypeHint>)` 指令模式（定义在核心库），用于在 NPL 代码中需要强制将一个已存在的、由 NL 描述的 `Datum` 解释为特定结构时使用，以提供额外的控制和明确性。

## 6. 工作机制：增强的认知解释与执行

NLD 的核心在于其**认知执行模型**，现在进一步明确了 NL 与 NPL 的交互机制：

1. **接收 NLD 构造/调用**: 认知实体在其 NPL 运行时中处理 NLD 定义或调用。
2. **理解 NPL 结构**: 解析 NPL 语法部分（关键字、名称、参数签名、`->` 提示）。这些提供了硬性约束。
3. **预处理 NL 主体**: NPL 运行时在将 NL 主体交给核心理解模块前，对其进行**预处理**，识别所有 `{{ }}` 和 `{% npl %}` 标记。
4. **Datum 绑定 (`{{ }}`)**: 对于 `{{ datum_handle }}` 标记，运行时解析句柄（包括属性/索引访问），在当前 NPL 上下文中查找对应的 `Datum`，并准备好其值（或值的 Representamen）以供后续使用（例如，替换占位符，或作为信息传递给 NL 理解核心）。
5. **NPL 块处理 (`{% npl %}`)**:
    - **执行时机**: 推荐采用**运行时回调**机制。即，当 NL 理解核心处理到 `{% npl %}` 标记所在的位置时，回调 NPL 运行时执行该 NPL 代码块。
    - **上下文感知**: 这种回调方式允许 NPL 块潜在地访问（如果实现支持）部分当前的 NL 处理上下文，使其执行能更好地融入 NL 流程。
    - **副作用/结果**: NPL 块的执行可能会产生副作用（如日志记录、状态更新）或影响后续的 NL 理解过程。
6. **理解 NL 主体 (核心)**: 认知实体启动其核心的**符号过程（`Semiosis`）**，结合**已绑定的 Datum 信息**和**NPL 块的执行逻辑/结果**，来理解 NL 描述的**意图、内容和需求**。
7. **执行认知任务**:
    - **对于 NLD 过程**: 基于对（经过处理和增强的）NL 主体的理解，规划并执行一系列内部认知操作。
    - **对于 NLD 数据/对象**: 基于对（经过处理和增强的）NL 主体的理解，在内部构建一个概念性的数据结构或对象表示。
8. **输出符合结构的 Sign/Object**: 认知实体必须努力使其最终形成的内部解释项（`Interpretant`），在外部化（`Externalization`）为一个 `Sign`/`Object` 时，**严格符合 `->` 提示所指定的类型或结构**。如果 NL 描述与结构提示冲突，应优先满足结构提示，并在 CT 中记录。
9. **返回 Datum 句柄**: 返回指向新生成的、符合结构的 `Sign`/`Object` 的 `Datum` 句柄。
10. **强制认知轨迹 (CT)**: 由于 NLD 依赖于对 NL 的理解，并且现在包含了更复杂的 NL-NPL 交互，其执行过程不确定性较高。因此，**强制要求**认知实体生成**极其详尽**的认知轨迹（`CT`），记录其解释、推理、决策过程，**特别是 Datum 绑定、NPL 块执行细节，以及如何确保输出符合结构要求**。

## 7. 应用：更优雅、更强大的 NPL 库和文档

引入 `{{handle}}` 和 `{% npl ... %}` 的 NLD 机制将显著提升 NPL 生态的开发体验：

- **提升精确性**: 显著减少 NL 指代的模糊性。
- **增强灵活性**: 方便在 NL 流程中嵌入简单的 NPL 逻辑。
- **促进“有机结合”**: 使 NL 和 NPL 在 NLD 定义中更紧密、自然地协同工作。
- **库定义**: 允许用 NLD 定义核心逻辑，使库结构更清晰。
- **自文档化**: NLD 定义中的 NL 主体本身就是高层描述。
- **降低门槛**: 用更自然的语言定义复杂认知逻辑。
- **提升一致性**: 通过 `->` 提示规范输出结构。