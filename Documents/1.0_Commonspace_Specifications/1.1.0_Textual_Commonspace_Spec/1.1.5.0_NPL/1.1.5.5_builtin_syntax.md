# NPL 内置语法：NPL 运行时认知指令 (`CD`) 的结构

NPL 的内置语法定义了构建 NPL **符号 (`Sign`)** 的规则，这些 `Sign` 在 `Cognitor` 内部的 **NPL 运行时**中作为**认知指令 (`CD`)** 被处理。语法结构利用编程隐喻提供 `Constraint`。

## 1. 句柄赋值 (`=`): 在运行时中建立引用

* **语法**: `handle = expression`
* **意图**: 指导 `Cognitor` 在其 NPL 运行时中，评估 `expression`（可能涉及创建概念性对象、调用 `CD` 模式或引用字面量 `Sign`），并将结果与 `Datum` 句柄 `handle` 建立关联。

## 2. 点 (`.`) 操作符: 应用运行时 CD 模式

* **语法**: `datum_handle.cd_pattern_name(...)`
* **意图**: 指导 `Cognitor` 将名为 `cd_pattern_name` 的 `CD` 模式应用于 `datum_handle` 在运行时指向的概念性对象或 `Sign`。

## 3. 引用 (`Quote` 句柄): 指向历史 `Sign`

* **概念**: NPL 运行时中表示对 `Space` 中历史 `Sign` 的引用的特殊 `Datum` 句柄。
* **语法**: 通过特定 `CD` 模式（如 `cts[...]` 或 `Canvas.find_rendered_node(...)`）获得。

## 4. 注释 (`#`, `//`, `/**/` 等)

* **作用**: 作为 NPL `Sign` 的一部分，为 `Cognitor` 处理该 `CD` 时提供附加 `Constraint` 或解释。

## 5. 自然语言嵌入

* **作用**: 作为 `Sign` 的一部分提供 `Constraint`，需要 `Cognitor` 的语言理解能力。

## 6. 控制流结构: 指导运行时认知流程

* **核心概念**: 控制流结构 (`if`, `for`, `while`) 指导 `Cognitor` 在其 **NPL 运行时**中**模拟执行流程**。
* **`if`/`elif`/`else`**: 指导 `Cognitor` 在运行时评估条件 (`Datum` 指向的 `Object`)，并根据结果选择性地处理后续 `CD` 块。CT 记录评估和选择。
* **`for...in`**: 指导 `Cognitor` 在运行时模拟对 `iterable_datum` 指向的概念性集合的迭代。**对于每次迭代**，处理循环体内的 `CD`。**CT 记录每次迭代的开始、处理和结束**。（不再强制要求在 CT 中生成单步指令，模拟发生在运行时内部，但 CT 仍需详细记录模拟的每一步）。
* **`while`**: 指导 `Cognitor` 在运行时**重复模拟**：评估条件（记录 CT），若为真，则处理循环体 `CD`（记录 CT），直到条件为假（记录 CT）。

## 7. 库导入 (`import` )

* **语法 (类 Python)**:
    * `import library_name`
    * `import library_name as alias`
    * `from library_name import symbol1, symbol2 as alias2`
    * `from library_name import *`
* **意图**: 指导 `Cognitor` 在其 NPL 运行时的当前作用域中**识别并使能**来自指定库 (`library_name`) 的符号（概念性类、`CD` 模式、常量等）。这是使用库（如 `canvas`, `spacelog`）功能的前提。
* **认知过程**: `Cognitor` 需要知道哪些库是可用的，并在处理 `import` 指令时更新其运行时的符号表或识别能力。CT 应记录成功导入的库和符号。