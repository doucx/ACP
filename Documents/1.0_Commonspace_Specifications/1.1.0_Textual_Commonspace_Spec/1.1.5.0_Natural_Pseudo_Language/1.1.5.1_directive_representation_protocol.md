# NPL 指令表示协议

> 基于： [[1.1.1_protocol_requirements]]

## 1. NPL 的本质：基于编程语言隐喻的认知指令系统

**核心定位**: NPL (Natural Pseudo Language) 是一个运行在 **`Cognitor` 内部概念性的“NPL 运行时” (NPL Runtime)** 环境中的、基于**编程语言隐喻**的系统。该系统旨在创建结构化的、低歧义性的文本**符号 (`Sign`)**。这些 NPL `Sign` 作为**认知指令 (`Cognitive Directive`, `CD`)**，为处理它们的 `Cognitor` 提供清晰、强力的**约束 (`Constraint`)**，以精确地引导其内部的**符号过程 (Semiosis)**，使其形成的**解释项 (`Interpretant`)** 趋向于指令所意图的**对象 (`Object`)**。

> 注：需要更多理论依据，如 BNF 范式
> 需要考虑语法学和语义学

### 1.1 NPL 运行时 (NPL Runtime) 概念

* 每个 `Cognitor` 内部都包含一个概念性的 NPL 运行时环境。
* 这个运行时负责处理（解释并遵循）NPL `Sign` (CDs)。
* 它维护着当前 NPL 代码执行的状态，包括已定义的 `Datum` 句柄及其指向的概念性对象或 `Sign`。
* NPL 的“执行”是在这个运行时中，由 `Cognitor` 的认知能力驱动的符号过程。

### 1.2 隐喻机制解释

* NPL 利用**编程语言结构**（如变量赋值、库导入、类实例化、方法调用、控制流）作为**源领域隐喻**。
* 这些结构通过 NPL 语法 (`Representamen`) **映射**到**目标领域**——即 `Cognitor` 的内部认知活动（理解指令、管理状态、调用能力、规划流程等符号过程）。
* 这种隐喻使得 NPL `Sign` (CDs) 能有效利用 `Cognitor` 已有的结构化处理能力，提供比纯自然语言更精确的 `Constraint`。

**关键前提**: NPL 的力量源于 `Cognitor` 对 NPL `Sign` 的**理解**以及在其内部 NPL 运行时中**遵循其指导**进行符号过程的能力。**它不是外部代码执行**。

## 2. NPL 的核心目标与哲学

1.  **认知指令 (`CD`)**: NPL 是创建和传递 `CD` 的工具，旨在影响接收方 `Cognitor` 在其 NPL 运行时中的符号过程。
2.  **认知运行时处理**: `Cognitor` 在其 NPL 运行时中处理 NPL `Sign`，这是一个内部符号过程，而非外部模拟。
3.  **面向内部状态与概念**: NPL 主要用于引导 `Cognitor` 在其 NPL 运行时中创建、配置和操作概念性对象（如 Canvas Node 的配置），或管理其内部追踪的状态。
4.  **依赖原生理解力**: 结构化是为了辅助 `Cognitor` 的理解和符号处理。
5.  **结果外显化**: NPL 运行时处理的结果，最终通过特定指令（如 `canvas.render`）**外显化**为添加到 `Space` 的新 `Sign` (XML Node) 或通过 `CT Sign` 记录下来。
6.  **模块化与库**: 通过**库导入**的隐喻 (`import` 指令)，NPL 支持将特定领域（如 Canvas 操作）的功能封装起来，提高了模块化和可扩展性。
7.  **元编程指导**: 控制流等结构指导 `Cognitor` 在其 NPL 运行时中规划和模拟执行流程，并通过 `CT` 记录。

## 3. NPL 与符号学原理

* **NPL `Sign`**: 每个 NPL 语句是一个结构化的 `Sign`，其 `Representamen` 利用编程隐喻。
* **隐喻结构 = 强 `Constraint`**: 语法结构提供强约束，引导 `Semiosis`。
* **目标 = 精确引导 `Interpretant`**: 减少歧义，使 `Cognitor` 形成的 `Interpretant` 更符合 `CD` 的意图 (`Object`)。
* **处理 NPL = 在 NPL Runtime 中执行受约束的 Semiosis**: `Cognitor` 在其 NPL 运行时中，根据 NPL `Sign` 提供的 `Constraint` 进行符号过程。
* **`CT` 记录过程**: `Cognitor` **必须**通过 `CT Sign` 记录其在 NPL 运行时中处理 NPL `CD` 的关键符号过程。

## 4. 对 Cognitor 实现者的指导

实现能处理 NPL 的 `Cognitor` 意味着要实现其**内部的 NPL 运行时环境**：

1.  **解析 NPL `Representamen`**: 包括 `import` 等新语法。
2.  **实现 NPL 运行时状态管理**: 管理 `Datum` 句柄、概念性对象实例。
3.  **理解隐喻映射**: 将 NPL 结构映射到内部认知操作。
4.  **执行符号过程**: 根据 NPL `CD` 提供的 `Constraint` 进行推理和状态更新。
5.  **实现核心 CD 模式**: 包括库导入、对象实例化、配置、渲染/外显化等。
6.  **记录 NPL 运行时 CT**: 详细记录在 NPL 运行时中发生的符号过程。
7.  **核心：模拟运行时，驱动认知**: 构建一个能够模拟脚本执行流程，并以此驱动自身认知活动和与 `Space` 交互的内部机制。