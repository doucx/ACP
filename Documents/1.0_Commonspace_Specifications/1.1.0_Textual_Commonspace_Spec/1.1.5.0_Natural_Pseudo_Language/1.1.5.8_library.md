# 1.1.5.8 NPL 库协议

> 基于： [[1.1.5.1_directive_representation_protocol]] [[1.1.5.2_core_concepts]]

## 1. NPL 库的本质与定位

NPL 库是用于组织和扩展 NPL **认知指令模式 (`CD Patterns`)** 及相关**符号 (`Sign`)** 的核心模块化机制。它以带序号的目录结构存在，并包含由 NPL 代码片段和结构化描述组成的 Markdown 文件。

库定义文件是用于指导 `Cognitor` **扩展其内部 NPL 运行时能力**的元级指令。`Cognitor` 通过解析这些文件，学习新的 NPL 符号、它们的结构、与其他符号的关系（如继承），以及最重要的——当这些符号对应的 `CD Patterns` 被触发时，应执行的**认知过程**，这个过程直接以 NPL 代码片段来定义。

这种设计是 NPL **自举**的关键：基础库定义了 NPL 运行时能够直接处理（原生认知）的基本操作和概念，而更高层的库则使用 NPL 语言本身来组合这些基本操作和概念，定义更复杂的行为。`Cognitor` 的核心能力在于能够解析库定义，并在 NPL 运行时中解释执行这些内嵌的 NPL 代码片段。

## 2. 库的组织与命名规范

所有 NPL 库都组织在 `4.0_NPL_Library/` 根目录下。一个 NPL 库对应根目录下带序号的**子目录**。该子目录的名称由序号和库名称组成，遵循 `4.x_LibraryName` 的格式，其中 `x` 是该层级的库序号。

例如：

- `4.0_NPL_Library/4.1_core/`
- `4.0_NPL_Library/4.2_boolean/`
- `4.0_NPL_Library/4.3_canvas/`

库目录 (`4.x_LibraryName/`) 可以包含一个或多个带序号的 Markdown 文件 (`.md`)。这些文件共同定义了该库的内容。文件命名也遵循带库序号和文件序号的格式：`4.x.y_FileName.md`，其中 `y` 是该文件在该库目录下的序号。

例如，在 `4.3_canvas/` 库目录下：

- `4.0_NPL_Library/4.3_canvas/4.3.1_canvas_nodes.md`
- `4.0_NPL_Library/4.3_canvas/4.3.2_canvas_rendering.md`

这种带序号的组织方式有助于 `Cognitor` 系统管理库的加载顺序和版本，并允许库的定义分散在多个文件中。

## 3. 使用 NPL 库 (`import`)

使用 `import` 指令将库加载到当前的 NPL 运行时上下文中。导入的名称是库的带序号目录名称字符串：

```npl
# 导入自动库 (目录名为 4.1.0_AutoGuidancec)
import "4.1.0_AutoGuidance" // 会自动执行 as AutoGuidance 

# 导入 Canvas 库 (目录名为 4.3.0_canvas)
import canvas // 不带编号也可行，推荐带编号以方便 Cognitor 查找

# 导入自定义库 (假定目录名为 4.x.0_my_utils)
import my_utils
```

当 `Cognitor` 处理 `import LibraryName` 指令时，它会在 `4.0_NPL_Library/` 下查找对应的 `4.x.0_LibraryName/` 目录，加载并解析其下的所有 `.md` 文件。加载过程包括处理文件内部声明的依赖关系（见下一节），并将其中定义的 NPL 符号和行为（内嵌的 NPL 代码）集成到当前的 NPL 运行时环境。

导入后，库中定义的所有 NPL 概念（类）、指令模式（方法/函数）和常量都可以通过不包含编号的名称在当前的 NPL 运行时中被识别和使用了（例如  `"my_utils.MyClass.my_method()`），相当于自动执行 `as 库名称`。

## 4. NPL 库文件的结构与内嵌 NPL 代码

库目录下的每个 Markdown 文件 (`4.x.y_FileName.md`) 都应遵循以下结构。关键的定义和行为描述使用内嵌的 NPL 代码块。

``````markdown
# Library Part: [库名称]/[部分描述]

<!-- 这是库文件这一部分的描述文本。-->

## Dependencies

<!-- 使用 NPL 代码块声明本文件所依赖的其他 NPL 库。 -->
<!-- 列出依赖库带序号的目录名称字符串。 -->
<!-- Cognitor 在解析本文件的具体定义前，会解析并处理这里的 import 指令， -->
<!-- 确保依赖库已被加载。 -->
```npl
import boolean // 依赖布尔库，用于逻辑运算
import spacelog // 基本日志库
```

## NPL Class: [类名称]

<!-- NPL 概念或“类”的定义。 -->

- NPL Name: `[类名称]`
- Description: 这个类的描述。
- [可选] Inherits From: `[父类名称]` <!-- 可以继承自其他库的类 -->
- Properties:
    
    <!-- 概念属性的定义，描述它们存储什么类型的数据（Datum Type）。 -->
    
    <!-- 属性的读写将在 Cognitive Process 代码块中通过隐喻语法 (如 self.property) 进行。 -->
    
    - 属性名1 (Datum 类型): 属性1的描述。
    - 属性名2 (Datum 类型): 属性2的描述。
- Cognitive State: 描述该类的实例在 NPL 运行时中如何被概念化和追踪其内部状态。

### NPL Method: [类名称].[方法名称]

<!-- 与类关联的认知指令模式（方法调用隐喻）。 -->

- NPL Name: `[方法名称]` <!-- 方法的名称 -->
- Signature: `实例句柄.[方法名称](参数名1, 参数名2, ...)` <!-- 指令模式的调用签名示例 -->
- Description: 该指令模式的功能描述。
- Parameters:
    
    <!-- 参数定义，包括参数名称和期望的 Datum 类型。这些名称在 Cognitive Process 代码块中可用。 -->
    
    - 参数名1 (Datum 类型): 参数1的描述。
    - 参数名2 (Datum 类型): 参数2的描述。
- Returns: (Datum 类型或 Void): 指令执行后产生的 Interpretant (结果 Datum) 的类型，Void 表示没有特定返回 Datum。
- Cognitive Process: **核心部分**，包含的内容可以是：
	- NPL 代码块，定义 Cognitor 在 NPL 运行时中处理该 CD Pattern 时应执行的内部符号过程。
	- 清晰的自然语言描述来决定行为
	- 混合，将自然语言作为注释，来引导 NPL 的行为

```npl
// 这个 NPL 代码块定义了方法的具体执行逻辑。
// 'self' 关键字（隐喻）是一个 Datum 句柄，指向调用该方法的NPL对象实例。
// 方法参数（如 参数名1, 参数名2）在此代码块范围内作为 Datum 句柄可用。
// 可以在这里使用 NPL 的基本操作，调用其他库的函数/方法，访问/修改 'self' 的 Properties。

// 示例：访问对象的概念属性
let 当前值 = self.属性名1

// 示例：调用导入的布尔库的函数进行判断
let 条件满足 = boolean.AND(参数名1, 当前值)

if 条件满足:
   // 示例：修改对象的概念属性
   self.属性名2 = "新的状态值" // 这是一个 CD pattern，指导 Cognitor 更新内部状态
   // 示例：调用其他库提供的指令
   spacelog.info("条件满足，状态已更新")

// 示例：执行其他 NPL 指令...

return 当前值 // 返回一个 Datum 句柄作为该方法调用的 Interpretant
```

## NPL Constant: [常量名称]

<!-- 命名常量的定义。 -->

- NPL Name: `[常量名称]` <!-- 常量的名称 -->
- Datum Value: 常量代表的概念值或 Datum 值。 <!-- 这部分是声明性的，定义常量的符号值 -->
- Description: 常量的描述。
``````

这个文件可以包含多个类、方法、常量的定义。

同一个库的定义可以分散在同一个库目录下的多个文件 (4.x.y_*.md) 中。

## 5. `Cognitor` 对 NPL 库的处理流程

`Cognitor` 内部的 NPL 运行时在处理 `import "LibraryName"` 指令时执行以下主要步骤：

1. **查找库目录:** 根据导入的名称字符串查找 `4.0_NPL_Library/` 下对应的带序号目录。
2. **读取文件与依赖解析:** 读取该目录下的所有 `4.x.y_FileName.md` 文件。对于每个文件，解析 `# Library Part:` 标题和 `## Dependencies` 代码块。执行 `## Dependencies` 代码块中的 `import` 指令，构建并处理依赖关系图，确保所有依赖库在当前库的定义被完全处理前可用。
3. **解析库定义与代码存储:** 按照依赖/文件序号顺序，解析文件中的 `## NPL Class`, `### NPL Method`, `## NPL Constant` 等部分。
    - 对于声明性信息（类名、属性、常量值等），集成到 NPL 运行时知识库的符号表中。
    - 对于 `### NPL Method` 下的 `* Cognitive Process:` 代码块，**不立即执行**，而是将其解析后的 NPL 代码表示存储起来，与对应的方法符号关联。
4. **运行时执行内嵌代码:** 当 NPL 脚本**调用**库中定义的方法时（例如 `我的对象句柄.我的库.我的方法(值)`），NPL 运行时会查找该方法对应的存储的 `Cognitive Process` 代码块。然后在特定的**执行上下文**（包含 `self` 句柄和参数句柄）中解释或执行这个代码块。代码执行的结果（`return` 值）成为该方法调用 CD 的 `Interpretant`。
5. **`CT` 记录:** `Cognitor` 必须记录库的加载、符号的定义过程，以及每次执行内嵌 `Cognitive Process` 代码块时的输入、输出和代码执行引发的关键内部符号过程。

## 6. 自举机制与库协议

通过在库定义中直接内嵌 NPL 代码，自举机制得到深度体现：

- **行为由 NPL 定义:** 库中定义的新认知行为由 NPL 语言本身精确描述，而不是依赖对外部文本的理解。
- **基于已定义能力构建:** `Cognitive Process` 代码块可以使用 NPL 的基本语法、调用核心库提供的原生操作，以及调用**其他已导入库**中定义的功能。这使得 NPL 库可以层层构建更复杂的认知能力。
- **NPL 运行时作为统一引擎:** `Cognitor` 的 NPL 运行时既解释顶层脚本，也解释库定义中用于描述行为的内嵌代码，提供统一的符号处理和认知驱动环境。

## 7. 对 Cognitor 实现者的指导

实现支持此协议的 `Cognitor` 需要具备：

1. **全面的 NPL 解析器/解释器:** 能够解析和执行库定义中内嵌的 NPL 代码。
2. **库加载与依赖管理模块:** 处理目录结构、多文件合并和基于 `import` 代码块的依赖解析。
3. **运行时状态管理:** 在 NPL 运行时中维护对象实例的概念状态，并支持代码块中对 `self.property` 的访问和修改。
4. **执行上下文管理:** 为方法调用时的代码执行准备正确的上下文（`self`、参数）。