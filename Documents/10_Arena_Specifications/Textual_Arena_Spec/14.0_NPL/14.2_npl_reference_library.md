# NPL 参考库
本文档提供了 NPL 内置核心概念交互句柄、变量、函数、类及配置选项的参考信息。

## 1. 核心概念交互参考

### 1.1. `Forma` (确定性实体)

代表形式上确定的信息载体（如文本字符串、数字）。

*   **`__uncertainty__`**:
    *   签名: `forma_instance.__uncertainty__ -> Uncertainty`
    *   作用: 获取一个 `Uncertainty` 句柄，该句柄指向与“重新解读此 `Forma` (文本内容) 在当前上下文中可能产生的**意义不确定性**”相关联的 `Uncertainty` 状态。原 `Forma` 的内容成为这个新 `Uncertainty` 的一个初始的、强有力的**约束 (`Constraint`)**。这允许 `Cognitor` 对一个已经确定的形式进行二次审视和意义探索。
    *   示例（概念性）：对于 `Forma` 实例 `my_number = 5` (文本"5")，执行 `Uncertainty(my_number)` 得到一个 `Uncertainty` 句柄，`Cognitor` 可以开始思考“这个'5'代表什么？” (`Uncertainty`)，而"5"这个文本 `Forma` 本身是其核心 `Constraint`。
	*   字符串前缀： `u"苹果"` 相当于 `Uncertainty("苹果")`

### 1.2. `Uncertainty` (不确定性实体)

代表需要 `Cognitor` 进行认知处理以确定其意义或具体内容的**不确定性状态**。在 Textual Arena 中，这通常指代由一段文本 (`Forma`) 引发的意义可能性空间。

*   **通用约束方法:**
     - `add_constraint(constraint: Forma)`: 添加一个文本形式的约束 (`Forma`)。这个 `constraint` (`Forma`) 被用来**引导 `Cognitor` 对该 `Uncertainty` 指向的可能性空间进行更精确的理解和管理**。`Cognitor` 基于其语言理解能力来解读这个 `Forma` 约束并应用它来缩小 `Uncertainty`。
    - `get_constraints() -> List[Forma]`: 获取施加在该 `Uncertainty` 上的所有 `Forma` 约束列表。

*   **`fill()`**:
    *   作用: 这是一个**请求 `Cognitor` 动用其核心认知能力**的操作。`Cognitor` 需要评估当前 `Arena.context` (整体上下文 `Forma` 作为隐式 `Constraint`) 以及所有通过 `add_constraint` 显式添加的 `Forma` 约束，利用 `Cognitive Trace`， 对该 `Uncertainty` 句柄指向的不确定性状态进行**深度理解、推理和信息补全**，尝试**最大限度地消解其模糊性**，使其意义在当前上下文中更加明确。这是一个依赖 `Cognitor` 应用约束能力的**解释和精化过程**。

*   **`__forma__()`**:
    *   作用: 请求 **`Cognitor`** 基于预定义的转换规则（通常由 `Cognitor` 根据上下文自动推断）和所有已应用的 `Forma` 约束，将这个 `Uncertainty` **尽可能地解析和固化为一个确定性实体** (`Forma`)。这是 `Cognitor` 在应用所有约束后，做出最终判断或创建确定性输出的动作。

*   **`yaml(max_nesting_depth=..., mode=..., ...) -> Forma`**:
    *   作用: 以 YAML 格式 (`Forma`) 输出该 `Uncertainty` 的结构化描述，包括其当前状态和已应用的约束，可控制递归深度和模式。

*   **`pick(num=1, ...)`**:
    *   作用: 请求 **`Cognitor`** 从该 `Uncertainty` 句柄所代表的**多种可能性意义**中，根据当前所有 `Forma` 约束（显式和隐式），提取出 `num` 种**最具代表性或差异性的具体解读**。这些解读通常以 `Forma` (如具体的文本描述或数值) 或更具体的 `Uncertainty` 描述形式返回。


### 1.3. `Cognitor` (认知实体)

指向 `Cognitor` 信息的 `Forma` 句柄。

属性：
*   **`info`**:
    * 作用：指向 `CognitorInfo` 中该 `Cognitor` 的 `yaml` 格式信息 (`Forma`)。
*   **`name`**:
    * 作用: 指向该 `Cognitor` 的名字 (`Forma`)。
*   **其余属性**:
	* 与 `self.info` (`Forma`) 中的结构相同，如 `Cognitor.type` 等。

方法：
*    **fill(from=Arena)**:
	* 作用: 根据当前的整个上下文 `Arena` (`Forma` 作为主要 `Constraint`)，尝试填充 `self.info` (`Forma`) 中可能存在的缺失信息或不确定性。
	* 方式:
        1. 对 `self.info` 这个 `Forma` 执行 `to_uncertainty()`，得到一个关于 `Cognitor` 描述的 `Uncertainty` 句柄。
        2. 将 `Arena` 作为主要 `Constraint` 应用于这个 `Uncertainty`。
        3. 执行 `fill()`，让 `Cognitor` 尝试利用约束补全信息，管理 `Uncertainty`。
        4. 执行 `to_module()`，将更新后的理解固化回 `self.info` (`Forma`)。

### 1.4. Arena (认知空间)

指向 Arena 元信息的 `Forma` 句柄。

属性：
*   **`cognitor: Cognitor`**:
    * 作用：指向当前**正在修改** `Arena` 的 `Cognitor` 的 `Forma` 句柄。

*   **`context: str`**:
    * 作用：指向当前 `Arena` 的内容的 `Forma` 句柄。

### 1.5. Cognitive Trace System (认知轨迹系统)

ACP 协议将记录认知过程的机制称为 **`Cognitive Trace System`**，其产物为 **`Cognitive Trace`** 。这是为了强调其作为认知活动结果 `Forma` 的本质。

在 NPL 中，创建 `Cognitive Trace` 条目的标准化工具对象被命名为 `ct` (例如 `ct.npl(...)`)。

所有的认知轨迹条目都是 Arena 的一部分。

为了满足 Cognitive Trace 的要求，`ct` 与常见认知轨迹系统不同的是，在 NPL 以及 Textual Arena 中，不存在“级别”的概念，只有“类型”的概念，相当于强制 “Verbose” 模式。

同时可以出现所有类型的认知轨迹条目。

类型：

#### NPL
`ct.npl(message)`

手动创建。

用于在 NPL 代码中显式输出需要的信息，而不干扰 stdout 。

#### TRACE

通过引用来指示当前正在执行的是哪个认知指令（如自然语言和NPL）。

引用需要包含：
1. 原认知指令的创建者
2. 该认知指令的简略形式

需自动创建。

#### INFO

有关 Cognitor 是怎么规划与执行的记录。

需自动创建。


## 2. `Auto` 类

`Auto` 类是 NPL 中**直接调用和引导 `Cognitor` 核心认知能力**（特别是推理和创建能力）的主要接口。它的核心机制在于将用户提供的**认知指令**（无论是自然语言描述 (`Forma`) 还是结构化条件 (`Forma`)）**视为施加于某个潜在 `Uncertainty` 上的复杂约束 (`Constraint`) 或处理目标**。`Auto` 方法会结合当前的 `Arena` (作为隐式 `Forma` 约束)，然后**请求 `Cognitor` 调用其能力**，尝试应用这些约束来管理目标 `Uncertainty`，并将其转化为一个相对确定的 `Forma` 或更明确的 `Uncertainty` 状态（例如，创建一段 NPL 代码 `Forma`、填充对象属性 `Forma`、执行一个推断出的操作）。

为了记录 `Cognitor` 在响应 `Auto` 请求时如何应用约束和管理 `Uncertainty` 的过程，使用任何 `Auto` 类的方法**通常会产生大量 `Cognitive Trace` **。

`from` 参数提供一段文本 (`Forma`) ，作为额外的显式**约束 (`Constraint`)**，用于**引导 `Cognitor` 的理解和创建方向**。

**"常识"的定义**  
常识包含三类信息：  
1. 当前ACP文档内容  
2. Arena 的内容  
3. 当前对话中已建立的共识  

这些内容需满足：  
- 具有普遍性（非特定Cognitor的专有知识）  
- 已成为 Forma
- 经Cognitor判断在当前语境下具有高可信度和适用性  

### **`Auto.autodef(target: Forma, from: Forma = 常识, ...)`** :

*   作用: 请求 **`Cognitor`** 自动为 `target` (`Forma`，描述概念的文本) 创建定义。`Cognitor` 会将 `target` 视为指向“需要定义什么”的 `Uncertainty` 的核心约束，并以 `from` 指定的文本 (`Forma`) 作为额外的知识来源和约束，运用其**理解和创建能力**，尝试管理这个 `Uncertainty`，最终创建一个能代表该定义的、结构化的 `Forma`（如类结构）或一段更详细的说明性文本 (`Forma`)。
*   关键字: `autodef`

### **`Auto.autofill(target: Forma, from: Forma = 常识, ...)`** :

*   作用: 请求 **`Cognitor`** 自动填充由 `target` (`Forma`，描述对象、概念或结构的文本) 所代表的内容中不确定的部分。`Cognitor` 会将 `target` 的待填充状态视为包含了需要管理的 `Uncertainty`（“缺失的信息是什么？”）。它从 `from` (`Forma`，通常是包含相关信息的描述性文本) 提供的约束和信息中提取细节，运用其**理解和关联能力**，尝试填充 `target` (`Forma`) 的表示，管理 `Uncertainty`，使其成为一个属性更明确、内容更完整的 `Forma` 或细化的文本描述 (`Forma`)。整个应用约束、管理 `Uncertainty` 的过程需要被详细地记录在**`Cognitive Trace`** 中。
*   关键字: `autofill`

### **`Auto.autolet(cond: Forma, target: Forma = auto, from: Forma = 常识, 原则: Forma = 最小修改, ...)`** :

*   作用: 请求 **`Cognitor`** 自动施加约束以满足特定条件。`Cognitor` 会将 `cond` (`Forma`，描述所需条件或状态的文本) 理解为目标状态，即一个强约束 (`Constraint`)。然后，它会分析 `target` (`Forma` 句柄，指向需要被约束的状态或对象及其关联的 `Uncertainty`)。基于 `from` (`Forma` 约束) 提供的上下文和 `原则` (`Forma` 约束，描述调整策略) ，`Cognitor` 运用其**推理和规划能力**，调整与 `target` 关联的状态表示 (`Forma`)，应用约束管理 `Uncertainty`，使其最终满足 `cond` (`Forma` 约束) 所描述的条件。
*   关键字: `autolet`

### **`Auto.auto(from: Forma = 常识, ...)`** :

*   作用: 请求 **`Cognitor`** 进入最高级别的自主模式。这代表了一个高度开放的请求，将当前的主要 `Uncertainty`（通常是“接下来应该做什么？”）交由 `Cognitor` 处理。`Cognitor` 被要求运用其**最高级别的理解、推理、规划和执行能力**，根据 `Arena` (整体 `Forma` 作为隐式约束) 和 `from` (`Forma` 作为额外的显式约束或提示) 提供的所有约束，**自主猜测用户最可能的意图（形成内部目标 `Forma`，即对核心 `Uncertainty` 的一种解读）**，并自动规划和执行其推断出的最合适的操作序列（内部通过管理 `Uncertainty` 和创建 `Forma` 进行思考和决策），尝试达成一个对用户有价值的确定的结果 (`Forma` 输出或状态改变，并通过输出 `Forma` 报告）。
*   关键字: `auto`

## 3. 内置语法与操作

### 3.1. 索引

*   **语法**: 使用点 (`.`) 访问对象属性或方法。这些是结构化的 `Forma`，提供了访问内部状态或应用特定约束 (`Constraint`) 的接口。在集合或概念空间中，可使用 `*` 作为通配符进行筛选（这是一种模式 `Forma` 作为 `Constraint`）。
*   **示例**: `苹果.*.颜色.eq(绿色).品种.名称` (这段 NPL `Forma` 包含多个约束：类型是苹果，颜色是绿色，要获取的是品种名称，应用这些约束于知识库 `Uncertainty` 来获取结果 `Forma`)。
*   **上下文**: 筛选通常基于常识或当前 `Arena` 的内容（一系列 `Forma` 约束）。

## 4. 内置对象与变量

### 4.1. `Doc`
* **作用**: 一个指向当前所有 ACP 文档 (`Forma` 集合) 的对象句柄 (`Forma`)。
* **方法**:
	* `Doc["NPL 参考库"]` (`Forma` 索引) 将会指向当前的参考库文档 (`Forma`)。
	* `Doc.search("参考库")` (搜索 `Forma` 作为 `Constraint`) 将会被自动推测其意图 (`Uncertainty` 管理)，最终也可能指向当前的参考库文档 (`Forma`)。

### 4.2. `Config`

*   **作用**: 一个指向当前 `Arena` 配置选项 (`Forma`) 的对象句柄。修改其属性会**立刻生效**（改变约束条件）。
*   **主要属性 (部分)**:
    *   `Config.autodef`: 是否在需要时自动调用 `Auto.autodef` 的约束。默认为 `True`。
    *   `Config.autofill`: 是否在需要时自动调用 `Auto.autofill` 的约束。默认为 `True`。
    *   `Config.auto`: 是否在需要时自动调用 `Auto.auto` 的约束。默认为 `True`。
    *   `Config.语法严格性`: NPL `Forma` 解析的严格程度约束 (`"high"`, `"low"`). 默认为 `"low"`。
    *   `Config.自动输入检测`: 是否自动解析 `<In>...</In>` 结构 (`Forma`) 的约束。默认为 `True`。
    *   `Config.uncertainty.max_nesting_depth`: `Uncertainty.to_yaml()` (`Forma` 输出) 默认的最大递归显示层数约束。默认为 `1`。
    *   `Config.安全等级`: 当前安全等级约束。默认为`high`以避免在工作场合出现不适宜内容。需要使用`force`修改。
    *   `Config.arena_format`: `Arena` 交互环境格式 (`Forma`) 的约束。当前可选 `"Canvas"`, `"Tracer"` 等。默认为 `"Canvas"`。
*   **方法**:
    *   `Config.to_yaml()`: 以 YAML 格式 (`Forma`) 输出当前所有配置项（约束）。