# NPL 参考库
本文档提供了 NPL 内置核心对象、变量、函数、类及配置选项的参考信息。

## 1. 核心对象方法参考

### 1.1. `Forma` (确定性实体)

*   **`to_uncertainty()`**:
    *   签名: `forma_instance.to_uncertainty() -> Uncertainty`
    *   作用: 将此确定性实体 (`Forma`) 重新视为一个 **`Language` 实例**，将其当前的确定性意义作为基础，但重新**开放其被进一步解读和约束的可能性空间**。这实际上是创建了一个指向这个新 `Language` 实例的 `Uncertainty` 句柄，使其重新进入待处理的 `Language` 流。
    *   默认行为：将此 Forma 的文本表示看作一段需要重新理解的 `Language`。
    *   示例（概念性）：对于 `Forma` 实例 `my_number = 5`，执行 `my_number.to_uncertainty()` 可能得到一个 `Uncertainty` 句柄，指向 `Language` "数字5"，允许 Cognitor 思考 "这个5是年龄吗？是数量吗？还是别的？"

### 1.2. `Uncertainty` (不确定性实体)

*   **通用约束方法:**
     - `add_constraint(constraint: Language)`: 添加约束。这里的 `constraint` 本身就是一段 `Language`，它被用来**引导 Cognitor 对该 `Uncertainty` 句柄指向的 `Language` 实例进行更精确的理解**。约束的类型（范围、类型、描述性文本等）由 Cognitor 基于其 `Language` 理解能力来解读和应用。
    - `get_constraints() -> List[Language]`: 获取施加在该 `Uncertainty` 句柄上的所有 `Language` 约束。

*   **`__str__()`**:
    *   作用: 返回该 `Uncertainty` 的一个简洁摘要描述。
*   **`to_yaml(max_nesting_depth=..., mode=..., ...)`**:
    *   作用: 以 YAML 格式输出该 `Uncertainty` 的结构化描述，可控制递归深度和模式（如只显示关键信息）。
*   **`fill()`**:
    *   作用: 这是一个**请求 Cognitor 动用其核心 `Language` 处理能力**的操作。Cognitor 需要基于当前的 `ArenaContext` (整体 `Language` 流) 和已通过 `add_constraint` 添加的 `Language` 约束，对该 `Uncertainty` 句柄指向的 `Language` 实例进行**深度理解、推理和信息补全**，尝试消解其模糊性，使其意义在当前上下文中更加明确。这是一个依赖 `Cognitor` 认知能力的**解释过程**。
    * 需要 `DEBUG` 级别日志记录 Cognitor 的思考过程。
*   **`pick(num=1, ...)`**:
    *   作用: 请求 **Cognitor** 从该 `Uncertainty` 句柄指向的 `Language` 实例所蕴含的**多种可能性意义**中，根据当前上下文和约束，提取出 `num` 种**最具代表性或差异性的具体解读**（通常以 `Forma` 或更具体的 `Language` 描述形式返回）。
*   **`to_module(log=True, rule=auto, ...)`**:
    *   作用: 请求 **Cognitor** 基于预定义的转换规则（通常由 Cognitor 根据上下文自动推断，`rule` 本身也是 `Language`）和已添加的 `Language` 约束，将这个 `Uncertainty` 指向的待处理 `Language` **固化为一个确定性实体** (`Forma`)。这是 Cognitor 做出最终判断或生成确定性输出的动作。

### 1.3. `Language` (语言)

见 [[11_language.md]]。

可使用所有 `Uncertainy` 的方法。

使用 `l"字符串内容"` 来表示这个字符串是一个 Language 实体。

### 1.4 `Cognitor` (认知实体)

指向 Cognitor 的信息。

属性：
*   **`info`**:
    * 作用：指向`CognitorInfo` 中该 `Cognitor` 的 `yaml` 格式信息。
*   **`name`**:
    * 作用: 指向该 `Cognitor` 的名字。
*   **其余属性**:
	* 与 `self.info` 中的结构相同，如 `Cognitor.type` 等。
方法：
*    **fill(from=ArenaContext)**:
	* 作用: 根据当前的整个上下文，填充新发现/涌现的信息，扩展 `self.info`。
	* 方式: 执行 `self.info.to_uncertainty()` 将其显式作为 `Uncertainty`，将当前整个 `ArenaContext` 的内容作为约束，再执行 `self.info.fill()` ，最后执行 `self.info.to_module()`。

### 1.5 Arena (认知空间)

指向 Arena 的元信息。

属性：
*   **`cognitor: Cognitor`**:
    * 作用：指向当前维护 `Arena` 的 `Cognitor`。

## 2. `Auto` 类

`Auto` 类是 NPL 中**直接调用和引导 `Cognitor` 核心 `Language` 处理能力**的主要接口。它的核心机制在于将用户提供的**认知指令**（无论是自然语言描述 (`Language`) 还是结构化条件 (`Language`)）**视为对某个潜在 `Language` 实例施加的约束或处理目标**。 `Auto` 方法会结合当前的 `ArenaContext` (`Language` 流) 作为额外的隐式上下文，然后**请求 `Cognitor` 调用其推理和生成能力**，尝试将目标 `Language` 实例处理或转化为一个相对确定的 `Forma` 或更明确的 `Language` 状态（例如，生成一段 NPL 代码、填充对象属性、执行一个推断出的操作）。

为了记录 `Cognitor` 在响应 `Auto` 请求时的内部 `Language` 处理过程，使用任何 `Auto` 类的方法**通常会自动提升日志级别至 `DEBUG`**。

`from` 参数提供的是一段 `Language`，用于**引导 `Cognitor` 的理解和生成方向**。

### **`Auto.autodef(target, from=常识, ...)`** :

*   作用: 请求 **Cognitor** 自动为 `target` (一段描述概念的 `Language`) 生成定义。`Cognitor` 会将 `target` 视为需要定义的核心 `Language`，并以 `from` 指定的 `Language` 作为知识来源和约束，运用其**理解和生成能力**，尝试推理并生成一个能代表该定义的、结构化的 `Forma`（如类结构）或一段更详细的说明性 `Language`。
*   关键字: `autodef`

### **`Auto.autofill(target: Language, from: Language = 常识, ...)`** :

*   作用: 请求 **Cognitor** 自动填充由 `target` (一段描述对象、概念或结构的 `Language`) 所代表的内容。`Cognitor` 会将 `target` 的待填充状态视为一个需要具体化的 `Language` 实例，并从 `from` (通常是包含相关信息的描述性 `Language`) 提供的约束和信息中提取细节，运用其**理解和关联能力**，尝试填充 `target` 的表示，使其成为一个属性更明确、内容更完整的 `Forma` 或细化的 `Language` 描述。
*   关键字: `autofill`

### **`Auto.autolet(cond: Language, target: Language = auto, from: Language = 常识, 原则: Language = 最小修改, ...)`** :

*   作用: 请求 **Cognitor** 自动施加约束。`Cognitor` 会将 `cond` (描述所需条件或状态的 `Language`) 理解为目标状态。然后，它会分析 `target` (需要被约束的 `Language` 实例，默认为当前上下文最相关的对象或状态)，将其视为可调整的 `Language`。基于 `from` 提供的上下文和 `原则` (描述调整策略的 `Language`)，`Cognitor` 运用其**推理和规划能力**，调整 `target` 的表示（或模拟调整其代表的状态），使其最终满足 `cond` 所描述的约束。
*   关键字: `autolet`

### **`Auto.auto(from: Language = 常识, ...)`** :

*   作用: 请求 **Cognitor** 进入全自动模式。这代表了一个高度开放的请求，将用户的整体意图视为一个需要 **Cognitor** 自行解读的、非常广泛的 `Uncertainty`（基于当前整体 `Language` 流）。`Cognitor` 被要求运用其**最高级别的理解、推理、规划和执行能力**，根据 `ArenaContext` (整个 `Language` 流) 和 `from` (`Language` 形式的额外提示或知识源) 提供的隐式和显式约束，**自主猜测用户最可能的意图（形成内部 `Language` 目标）**，并自动规划和执行其推断出的最合适的操作序列（内部通过驾驭 `Language` 进行思考和决策），尝试达成一个对用户有价值的确定的结果 (`Forma` 或状态改变，并通过 `Language` 输出报告）。整个猜测、规划和执行过程会被详细地记录在 `DEBUG` 级别的日志中。
*   关键字: `auto`

## 3. 内置语法与操作

### 3.1. 索引

*   **语法**: 使用点 (`.`) 访问对象属性或方法。在集合或概念空间中，可使用 `*` 作为通配符进行筛选。
*   **示例**: `苹果.*.颜色.eq(绿色).品种.名称` (筛选所有绿色苹果的品种名称)。
*   **上下文**: 筛选通常基于常识或当前 `Arena` 的知识库。

## 4. 内置对象与变量
### 4.1. `Doc`
* **作用**: 一个指向当前所有ACP文档的对象。
* **方法**:
	* `Doc["NPL 参考库"]` 将会指向当前的参考库文档。
	* `Doc.search("参考库")` 将会被自动推测（这个行为类似搜索，因此使用`search`）“参考库”的含义，并最终指向当前的参考库文档（`Doc["NPL 参考库"]`）。

### 4.2. `Config`

*   **作用**: 一个包含当前  `Arena` 配置选项的对象。修改其属性会**立刻生效**。
*   **主要属性 (部分)**:
    *   `Config.Loglevel`: 设置日志显示级别 (`"TRACE"`, `"DEBUG"`, `"INFO"`, `"WARN"`, `"ERROR"`, `"Silent"`). 默认为 `"INFO"`。
    *   `Config.autodef`: 是否在需要时自动调用 `Auto.autodef`。默认为 `True`。
    *   `Config.autofill`: 是否在需要时自动调用 `Auto.autofill`。默认为 `True`。
    *   `Config.auto`: 是否在需要时自动调用 `Auto.auto`。默认为 `True`。
    *   `Config.语法严格性`: 设置 NPL 语法解析的严格程度 (`"high"`, `"low"`). 默认为 `"low"`。
    *   `Config.自动输入检测`: 是否自动解析 `<In>...</In>` 结构。默认为 `True`。
    *   `Config.uncertainty.max_nesting_depth`: `Uncertainty.to_yaml()` 默认的最大递归显示层数。默认为 `1`。
    *   `Config.安全等级`: 当前的安全等级。默认为`high`。需要使用`force`修改。
    *   `Config.arena_format`: 用于配置 `Arena` 的用户界面及交互环境的格式风格。它决定了 `Arena` 如何以纯文本形式呈现输入、输出、日志信息和其他相关内容。默认为"Canvas"。可选值：
	    *  `"Canvas"`: 使用 类似 XML 的 格式进行结构化表示，提供更清晰的层次关系和元数据。有少量示例，更加结构化。
	    * 其他可扩展的格式，例如 `"json"`, `"yaml"` 等。
	    *  `"Shell"`: 模拟传统的命令行界面风格，使用简洁的文本标记和缩进。有大量示例。更加自然。
*   **方法**:
    *   `Config.to_yaml()`: 以 YAML 格式输出当前所有配置项。

## 5. 标准函数

### **`init()`**:

作用: 执行 `Arena` 的初始化序列。

**初始化序列**:
```npl
1. 说明自己将怎么处理 `Uncertainty`
2. 执行 NPL 文档中所有 `autodef` 函数，对函数的描述作为约束，函数的具体行为显示在日志中。作用：Uncertainty(Doc["NPL 参考库-标准函数"]).to_module()
```

### **`print(obj, end="\n", ...)`**:

作用: 将对象 `obj` 输出到标准输出 (`stdout`)。
参数: `end` 指定结尾字符（默认换行），可能支持其他类似 Python `print` 的参数。

### **`input(prompt="")`**:

作用: 从标准输入 (`stdin`) 读取用户输入的一行文本。
参数: `prompt` 可选的提示信息。
行为: 会暂停执行流等待用户输入。
参考: 详见《ACP 交互式环境指南》。

### **`eval(word: auto 评价性语言)`**:

作用: 向 `Arena` 提供关于其表现的反馈（使用评价性语言），`Arena` 可利用此反馈“估计”自身能力或调整行为。

### **`exec(code: str)`**:

`autodef exec`

作用: 执行作为字符串传入的 `code` 中的 NPL 语句。

### **`to_nature(npl_statement: str) -> str`**:

`autodef to_nature`

作用: 自动尝试将给定的 NPL 语句转化为自然语言描述。

### **`to_npl(natural_language: str) -> str`**:

`autodef to_npl`

作用: 自动尝试将给定的自然语言描述转化为 NPL 语句。

### **`force_exec(acp_statement: str)`**:

`autodef force_exec`

关键字：`force`
作用: 类似`sudo`，提升权限并强制执行指令。


### **`chat(value:str, [to:Cognitor]) -> str`**

`autodef chat`

关键字：`chat`。

作用: 向目标 Cognitor 发送信息，将该 Cognitor 的回复作为函数返回值。

原理：
```npl
case chat:
	with Arena.cognitor = to: // 使用with ，确定在写好 `stdout` 后，`to` 会将 `Arena` 设置为原来的 `Cogniotr`。
		// 此时 `Arena` 将由 `to` 进行维护。
		auto 自动判断要生成多少日志，输出它们
		auto 将回复写在stdout中
```

全局选项: `Config.default_chat_to = {某个Cognitor对象}`。只有设置该选项后才能直接使用`chat`关键字。否则，`to` 需要明确指定。