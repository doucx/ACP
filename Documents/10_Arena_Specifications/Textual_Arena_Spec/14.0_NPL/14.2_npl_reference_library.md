# NPL 参考库
本文档提供了 NPL 内置核心概念交互句柄、变量、函数、类及配置选项的参考信息。

## 1. 核心概念交互参考

### 1.1. `Representamen` (确定性实体)

`Representamen` 直接基于 `Commonspace` 存在，它不需要使用 `print` 等方法输出来显示其内容。对它的创建本身就已经在 `Commonspace` 中显示了。见 [[12_protocol_requirements]]。

而 `Representamen`（作为一种类型）用于在 NPL 中，标记函数的输出将由 `CT`，`CommonspaceLog`，`对 Commonspace.context 的添加` 等形式，直接显示在 `Commonspace.context` 中。

可使用 `fo"内容"` 来标记一段字符串被作为 `Representamen` 处理。

由于字符串，列表等类型的数据结构都由 Cognitor 模拟，包含 `Referent`，因此都不被视为 `Representamen`。

方法：

-   **`__uncertainty__()`**:
    -   签名: `forma_instance.__uncertainty__ -> Referent`

	-   作用: 获取一个 `Referent` 句柄，该句柄指向与“重新解读此 `Representamen` (文本内容) 在当前上下文中可能产生的**意义不确定性**”相关联的 `Referent` 状态。原 `Representamen` 的内容成为这个新 `Referent` 的一个初始的、强有力的**约束 (`Constraint`)**。这允许 `Cognitor` 对一个已经确定的形式进行二次审视和意义探索。

    -   示例（概念性）：对于 `Representamen` 实例 `my_number = 5` (文本"5")，执行 `Referent(my_number)` 得到一个 `Referent` 句柄，`Cognitor` 可以开始思考“这个'5'代表什么？” (通常能够根据 `my_number =` 直接判断出 `5` 的类型是 `int` )，而"5"这个文本 `Representamen` 本身是其核心 `Constraint`。

-  **`__repr__() -> Quote`**
	- 因为 `fo""` 的内容已经在输入后就存在于 Commonspace 中了。为了降低冗余，如果试图重复输出一个 `Representamen`（如 `print` ， `ct` 等方法），会产生一个 `Quote` 。
	- 如（概念性示例）：
		- Alice 输入了 `a = fo"这创建了一个对该 Representamen 的引用。"`，执行 `print(a)` 输出 `Quote: { creater=Alice, "这创建...引用" }`。


### 1.2. `Referent` (不确定性实体)

在 NPL 中，指向一个 `Referent` 的 `Representamen` 句柄。见 [[12_protocol_requirements]]

代表需要 `Cognitor` 进行认知处理以确定其意义或具体内容的**不确定性状态**。在 Textual Commonspace 中，这通常指代由一段文本 (`Representamen`) 引发的意义可能性空间。

可使用 `Referent` 或 `U` 调用 `Referent` 类。

属性：

-    `cognitor: Cognitor`: 
	- 只读，用于标记这个 `Referent` 是谁管理的。代表第一次操作它的 操作者。

-    `constraints: list[Referent]`: 
	- 存放添加了的约束。

方法：

-    `add_constraint(CD: Representamen|Referent)`: 
	- 为该 `Referent` 添加一个约束。处理顺序（概念性）：
		1. `CD` 如果是 `Referent`，则不变，否则将被转化为 `CD: Referent`。
		2. 如果 `CD: Referent` 可以被 `Cognitor` 理解，则跳至 `4`。
		3. CD.add_constraint(auto 额外信息) （此处会产生递归）
		4. `Cognitor` 基于其语言理解能力来解读这个 `CD: Referent` 约束并将其添加到 `self.constraints` 中。

-    `get_constraints(CD) -> List[Representamen]`: 
	- 获取 `add_constraint` 过程中施加在该 `Referent` 上的所有 `Representamen` 约束列表。

-   **`__forma__(self, ...)`**:
    -   作用: 请求 **`Cognitor`** 基于预定义的转换规则（通常由 `Cognitor` 根据上下文自动推断）和所有已应用的 `Representamen` 约束，将这个 `Referent` **尽可能地解析和固化为一个确定性实体** (`Representamen`)。这是 `Cognitor` 在应用所有约束后，做出最终判断或创建确定性输出的动作。

-   **`__call__(self, CD: Representamen)`**:
    -   作用: 将该 `Referent` 视为一个可调用的函数，进行调用。如 `分析(苹果)` 。

-   **`fill()`**:
    -   作用: 这是一个**请求 `Cognitor` 动用其核心认知能力**的操作。`Cognitor` 需要评估当前 `Commonspace.context` (整体上下文 `Representamen` 作为隐式 `Constraint`) 以及 `self.constraints` 中所有约束内容，利用 `Cognitive Trace`， 对该 `Referent` 句柄指向的不确定性状态进行**深度理解、推理和信息补全**，尝试**最大限度地消解其模糊性**，使其意义在当前上下文中更加明确。这是一个依赖 `Cognitor` 应用约束能力的**解释和精化过程**。

-   **`yaml(max_nesting_depth=..., mode=..., ...) -> Representamen`**:
    -   作用: 以 YAML 格式 (`Representamen`) 输出该 `Referent` 的结构化描述，包括其当前状态和已应用的约束，可控制递归深度和模式。

-   **`pick(num=1, ...)`**:
    -   作用: 请求 **`Cognitor`** 从该 `Referent` 句柄所代表的**多种可能性意义**中，根据当前所有 `Representamen` 约束（显式和隐式），提取出 `num` 种**最具代表性或差异性的具体解读**。这些解读通常以 `Representamen` (如具体的文本描述或数值) 或更具体的 `Referent` 描述形式返回。

### 1.3. `Cognitor` (认知实体)

指向 `Cognitor` 信息的 `Representamen` 句柄。

属性：
-   **`info`**:
    - 作用：指向 `CognitorInfo` 中该 `Cognitor` 的 `yaml` 格式的信息。

-    **`default_chat_to`**:
	- 作用：设置 `chat` 的默认行为。

-   **其余属性**:
	* 与 `self.info` 中的结构相同，如 `Cognitor.name` 等。

方法：
-    **fill(from=Commonspace)**:
	* 作用: 根据当前的整个上下文 `Commonspace` (`Representamen` 作为主要 `Constraint`)，尝试填充 `self.info` (`Representamen`) 中可能存在的缺失信息或不确定性。
	* 方式:
```npl
uinfo = Referent(self.info) # 得到一个关于 `Cognitor` 描述的 `Referent` 句柄
uinfo.add_constraint(Commonspace.context) # 2. 将 `Commonspace` 作为主要 `Constraint` 应用于 `uinfo`。
uinfo.fill() # 让 `Cognitor` 尝试利用约束补全信息，管理 `Referent`。
with ct.say: self.info = Representamen(uinfo) # 将更新后的理解固化回 `self.info` (`Representamen`)。固化的最终内容会在 ct.say 中显示。
```

-    **exec(CD: Representamen)**:
	* 作用: 在该 `Cognitor` 的上下文中执行认知指令。

### 1.4. Commonspace (认知空间)

指向 Commonspace 元信息的 `Representamen` 句柄。

属性：

- **`cognitor: Cognitor`**
	- **类型**：动态占位符（Placeholder）
	- **作用**：
	  - 被调用时，`Commonspace.cognitor` 指向的是 **当前操作 `Commonspace` 的 `Cognitor`**。
	    - 具体来说，当某个 `Cognitor` 获取 `Commonspace` 时，`Commonspace.cognitor` 会自动更新为该 `Cognitor` 的身份。
	  - 这种机制确保了 `Commonspace.cognitor` 始终反映最新的调用者信息，而不是固定的创建者信息。用来标识“当前是谁在操作”。

- **`context: Quote`**
	- **类型**：引用（Quote）
	- **作用**：
	  - 被调用时，作为对创建该指令时`CommonspaceContext`的引用。

方法：

- **`release([cognitor: Cognitor])`**:
	- **作用**：
	  - 被调用时，要求 `Commonspace.cognitor` 释放 `Commonspace`。如果 `cognitor` 被设置，`cognitor` 将会成为 操作者。否则，将由 cognitors 竞争。
	  - 使用 `with Commonspace.release()` 临时释放 `Commonspace`，保证在结束后自己重新成为 操作者。

对 `Commonspace` 的获取将由 `Cognitor` 自行决定，遵从先来后到的规则。


### **1.5 Cognitive Trace System（认知轨迹系统）**  

#### **简介**  
`Cognitive Trace System`（CT 系统）是 **`Cognitor`**（认知实体，包括人类或程序化执行器）的行为记录规范，用于在 **`Commonspace`** 中创建描述其认知过程的 **`Representamen`** 条目。所有认知轨迹由 `Cognitor` 自主判断并动态创建，形成可追溯的逻辑链条。  

- **`CT`**（Cognitive Trace）：认知轨迹的**通用类型**，表示 `Cognitor` 在 Commonspace 中创建的任意一条认知行为记录。

- **`ct`**：用于**声明认知轨迹关注点**的工具对象，开发者通过它向 `Cognitor` 提示需要重点记录的代码范围（但最终是否记录仍由 `Cognitor` 自主决定）。

---

#### **核心特性**  
1. **类型化记录**  
   - 认知轨迹仅通过**类型**（`TRACE`/`THINK`/`SAY`/`ARENA`）区分行为性质，**不存在“级别”概念**。  
   - **不可省略任何类型**：所有 `Cognitor` 行为均需根据其语义创建对应类型的轨迹条目。  

2. **自主性控制**  
   - **默认行为**：`Cognitor` 根据上下文自动判断是否创建轨迹条目及类型，无需人工干预。  
   - **声明式提示**：通过 `with ct.<类型>` 语法向 `Cognitor` **提示**需关注的场景，但最终是否创建条目仍由其自主决定。  
     ```npl  
     # 提示 Cognitor 在此代码块中需关注 TRACE 和 THINK 类型的轨迹  
     with ct.trace, ct.think:  
         result = 计算权重()  # Cognitor 可能创建 TRACE 或 THINK 条目（但非强制）  
     ```  

3. **引用优化**  
   - 在 `TRACE` 类型中，通过 **`Quote`** 引用已有 `Representamen`，避免冗余内容重复记录。  

---

#### **类型定义**  
| 类型       | 用途                                                                 | 创建条件（由 Cognitor 判断）                 |  
|------------|----------------------------------------------------------------------|--------------------------------------------|  
| **`TRACE`** | 描述 **当前执行的认知指令**（自然语言或 NPL 片段）                     | 当执行关键逻辑时自动创建。       |  
| **`THINK`** | 描述 **内部推理过程**（如决策依据、逻辑链、思维链）                            | 当进行复杂计算、策略选择或异常处理时自动创建。 |  
| **`SAY`**   | 描述 **对外表达的自然语言内容**（如用户提示、交互反馈）                | 当向外部实体（如用户、其他系统）输出时自动创建。 |  
| **`ARENA`** | 描述 **对 Commonspace 的操作**（如获取/释放、路由）                  | 当操作 Commonspace 时自动创建。   |  

---

#### **使用规范**  
1. **禁止直接操作**  
   - **不可手动调用**如 `ct.say("内容")` 或 `ct.trace(...)`，所有条目由 `Cognitor` 自主创建。  

2. **声明式提示示例**  
   ```npl  
   # 提示 Cognitor 关注此代码块的 TRACE 和 ARENA 类型轨迹  
   with ct.trace, ct.arena:  
       chat 你好 # Cognitor 可能创建 TRACE（指令执行）和 ARENA（资源操作）条目  
   ```  

3. **引用优化示例**  
   ```npl  
   # 通过 Quote 减少重复内容  
   with ct.trace:  
       ... # 很长一段指令
       # Cognitor 可能创建 TRACE 条目并通过 Quote 引用该指令
   ```  

---

#### **设计原则**  
- **自主性**：`Cognitor` 全权控制轨迹的创建逻辑，人类仅提供语义提示。  
- **完整性**：覆盖认知过程的所有关键行为类型，无过滤机制。  
- **轻量化**：通过引用和结构化描述降低存储冗余。  

## 2. 内置类

### 2.1 `Auto`

`Auto` 类是 NPL 中**直接调用和引导 `Cognitor` 核心认知能力**（特别是推理和创建能力）的主要接口。它的核心机制在于将用户提供的**认知指令**（无论是自然语言描述 (`Representamen`) 还是结构化条件 (`Representamen`)）**视为施加于某个潜在 `Referent` 上的复杂约束 (`Constraint`) 或处理目标**。`Auto` 方法会结合当前的 `Commonspace` (作为隐式 `Representamen` 约束)，然后**请求 `Cognitor` 调用其能力**，尝试应用这些约束来管理目标 `Referent`，并将其转化为一个相对确定的 `Representamen` 或更明确的 `Referent` 状态（例如，创建一段 NPL 代码 `Representamen`、填充对象属性 `Representamen`、执行一个推断出的操作）。

为了记录 `Cognitor` 在响应 `Auto` 请求时如何应用约束和管理 `Referent` 的过程，使用任何 `Auto` 类的方法**通常会产生大量 `Cognitive Trace` **。

`from` 参数提供一段文本 (`Representamen`) ，作为额外的显式**约束 (`Constraint`)**，用于**引导 `Cognitor` 的理解和创建方向**。

-*"常识"的定义**  
常识包含三类信息：  
1. 当前ACP文档内容  
2. Commonspace 的内容  
3. 当前对话中已建立的共识  

这些内容需满足：  
- 具有普遍性（非特定Cognitor的专有知识）  
- 已成为 Representamen
- 经Cognitor判断在当前语境下具有高可信度和适用性  

#### **`Auto.autodef(target: Representamen, from: Representamen = 常识, ...)`** :

-   作用: 请求 **`Cognitor`** 自动为 `target` (`Representamen`，描述概念的文本) 创建定义。`Cognitor` 会将 `target` 视为指向“需要定义什么”的 `Referent` 的核心约束，并以 `from` 指定的文本 (`Representamen`) 作为额外的知识来源和约束，运用其**理解和创建能力**，尝试管理这个 `Referent`，最终创建一个能代表该定义的、结构化的 `Representamen`（如类结构）或一段更详细的说明性文本 (`Representamen`)。
-   关键字: `autodef`

#### **`Auto.autofill(target: Representamen, from: Representamen = 常识, ...)`** :

-   作用: 请求 **`Cognitor`** 自动填充由 `target` (`Representamen`，描述对象、概念或结构的文本) 所代表的内容中不确定的部分。`Cognitor` 会将 `target` 的待填充状态视为包含了需要管理的 `Referent`（“缺失的信息是什么？”）。它从 `from` (`Representamen`，通常是包含相关信息的描述性文本) 提供的约束和信息中提取细节，运用其**理解和关联能力**，尝试填充 `target` (`Representamen`) 的表示，管理 `Referent`，使其成为一个属性更明确、内容更完整的 `Representamen` 或细化的文本描述 (`Representamen`)。整个应用约束、管理 `Referent` 的过程需要被详细地记录在**`Cognitive Trace`** 中。
-   关键字: `autofill`

#### **`Auto.autolet(cond: Representamen, target: Representamen = auto, from: Representamen = 常识, 原则: Representamen = 最小修改, ...)`** :

-   作用: 请求 **`Cognitor`** 自动施加约束以满足特定条件。`Cognitor` 会将 `cond` (`Representamen`，描述所需条件或状态的文本) 理解为目标状态，即一个强约束 (`Constraint`)。然后，它会分析 `target` (`Representamen` 句柄，指向需要被约束的状态或对象及其关联的 `Referent`)。基于 `from` (`Representamen` 约束) 提供的上下文和 `原则` (`Representamen` 约束，描述调整策略) ，`Cognitor` 运用其**推理和规划能力**，调整与 `target` 关联的状态表示 (`Representamen`)，应用约束管理 `Referent`，使其最终满足 `cond` (`Representamen` 约束) 所描述的条件。
-   关键字: `autolet`

#### **`Auto.auto(from: Representamen = 常识, ...)`** :

-   作用: 请求 **`Cognitor`** 进入最高级别的自主模式。这代表了一个高度开放的请求，将当前的主要 `Referent`（通常是“接下来应该做什么？”）交由 `Cognitor` 处理。`Cognitor` 被要求运用其**最高级别的理解、推理、规划和执行能力**，根据 `Commonspace` (整体 `Representamen` 作为隐式约束) 和 `from` (`Representamen` 作为额外的显式约束或提示) 提供的所有约束，**自主猜测用户最可能的意图（形成内部目标 `Representamen`，即对核心 `Referent` 的一种解读）**，并自动规划和执行其推断出的最合适的操作序列（内部通过管理 `Referent` 和创建 `Representamen` 进行思考和决策），尝试达成一个对用户有价值的确定的结果 (`Representamen` 输出或状态改变，并通过输出 `Representamen` 报告）。
-   关键字: `auto`

### **2.2 Quote（引用）**  

**作用**  
`Quote` 是一种用于减少 `Commonspace` 中重复 `Representamen` 的机制，通过引用已有 `Representamen` 来降低Commonspace中的冗余。  

**核心属性**  
一个 `Quote` 可能包含以下信息，以确保能唯一标识被引用的 `Representamen`：  
1. **唯一序号**（Unique ID）  
   - 用于精确匹配被引用的 `Representamen`（如 `cts[Cognitor.name][X]`）。  
2. **创建者**（Originator）  
   - 标识该 `Representamen` 的原始创建者。  
3. **简略内容**（Summary）  
   - 提供可读的摘要，便于快速识别（如关键字段或特征）。  
4. **其它定位方式**（Alternative Locators）  
   - 如路径、URI、逻辑坐标等，支持灵活检索。  

**设计原则**  
- **唯一性**：通过组合属性（如 `创建者+ID`）确保引用精准。
- **轻量化**：存储引用而非完整 `Representamen`，降低书写开销。
- **可追溯性**：支持通过 `Quote` 反向查询原始 `Representamen` 的完整内容。

**适用场景**  
- 在`CT`中复用同一 `Representamen`。

## 3. 内置库

### 2.2. CommonspaceLog：NPL 日志库

#### 简介

CommonspaceLog 是 NPL 中用于记录程序运行状态、调试信息和错误信息的日志库。它提供了一种简单而灵活的方式，可以根据日志等级来控制日志的记录和输出，从而方便开发者诊断和解决问题。

由于 Commonspace 的特性，只有一个真正的输出流，即 Commonspace 本身。因此，CommonspaceLog 的实现非常简化，无需额外的配置或设置。

#### 用法

CommonspaceLog 提供了以下几个函数，用于记录不同等级的日志信息：

-   **`CommonspaceLog.debug(message: Representamen)`**: 记录调试信息。
-   **`CommonspaceLog.info(message: Representamen)`**: 记录一般信息。
-   **`CommonspaceLog.warning(message: Representamen)`**: 记录警告信息。
-   **`CommonspaceLog.error(message: Representamen)`**: 记录错误信息。
-   **`CommonspaceLog.critical(message: Representamen)`**: 记录严重错误信息。

每个函数都接受一个 `Representamen` 类型的参数，表示要记录的日志信息。

#### 日志等级

CommonspaceLog 的日志等级从低到高依次为：DEBUG、INFO、WARNING、ERROR、CRITICAL。默认的日志等级为 INFO，这意味着只有 INFO 及以上级别的日志信息会被记录。

可以通过设置 `Config.CommonspaceLog.level` 来修改日志等级，例如：

```npl
Config.CommonspaceLog.level = "DEBUG"  # 记录所有级别的日志信息
Config.CommonspaceLog.level = "WARNING"  # 只记录 ERROR 和 WARNING 级别的日志信息
```

**示例：**

```npl
CommonspaceLog.debug("这是一条调试信息。")
CommonspaceLog.info("这是一条一般信息。")
CommonspaceLog.warning("这是一条警告信息。")
CommonspaceLog.error("这是一条错误信息。")
```

**输出：**

CommonspaceLog 的日志信息会直接输出到 Commonspace 中，并作为 Commonspace 的一部分进行共享和传递。

#### **与 Cognitive Trace 的区别**  

| 维度          | **Cognitive Trace (CT)**               | **CommonspaceLog**                 |  
|---------------|----------------------------------------|------------------------------|  
| **目的**      | 记录认知实体的行为语义                  | 记录程序运行状态与诊断信息    |  
| **控制权**    | 由 `Cognitor` 自主创建                  | 由开发者手动触发              |  
| **内容性质**  | 类型化行为描述（无等级）                | 等级化日志（DEBUG/INFO 等）   |  


## 4. 内置语法与操作

### 4.1. 索引

-   **语法**: 使用点 (`.`) 访问对象属性或方法。这些是结构化的 `Representamen`，提供了访问内部状态或应用特定约束 (`Constraint`) 的接口。在集合或概念空间中，可使用 `*` 作为通配符进行筛选（这是一种模式 `Representamen` 作为 `Constraint`）。
-   **示例**: `苹果.*.颜色.eq(绿色).品种.名称` (这段 NPL `Representamen` 包含多个约束：类型是苹果，颜色是绿色，要获取的是品种名称，应用这些约束于知识库 `Referent` 来获取结果 `Representamen`)。
-   **上下文**: 筛选通常基于常识或当前 `Commonspace` 的内容（一系列 `Representamen` 约束）。

### 4.2 自然语言处理

自然语言可以被作为 NPL 对象处理。

### 4.3 注释

使用 `#`，`//` 和 `/**/` 进行注释。其它编程语言常见的注释也可被识别（如 `--` ）。

注释的内容将被作为 `Referent(怎么处理该NPL指令)` 的约束。也就是说，它可以影响 `Cognitor` 处理 `NPL` 的方式。


## 5. 内置对象与变量

### 5.1. `Doc`
- **作用**: 一个指向当前所有 ACP 文档 (`Representamen` 集合) 的对象句柄 (`Representamen`)。
- **方法**:
	* `Doc["NPL 参考库"]` (`Representamen` 索引) 将会指向当前的参考库文档 (`Representamen`)。
	* `Doc.search("参考库")` (搜索 `Representamen` 作为 `Constraint`) 将会被自动推测其意图 (`Referent` 管理)，最终也可能指向当前的参考库文档 (`Representamen`)。

### 5.2. `Config`

-   **作用**: 一个指向当前 `Commonspace` 配置选项 (`Representamen`) 的对象句柄。修改其属性会**立刻生效**（改变约束条件）。
-   **主要属性 (部分)**:
    -   `Config.autodef`: 是否在需要时自动调用 `Auto.autodef` 的约束。默认为 `True`。
    -   `Config.autofill`: 是否在需要时自动调用 `Auto.autofill` 的约束。默认为 `True`。
    -   `Config.auto`: 是否在需要时自动调用 `Auto.auto` 的约束。默认为 `True`。
    -   `Config.语法严格性`: NPL `Representamen` 解析的严格程度约束 (`"high"`, `"low"`). 默认为 `"low"`。
    -   `Config.自动输入检测`: 是否自动解析 `<In>...</In>` 结构 (`Representamen`) 的约束。默认为 `True`。
    -   `Config.uncertainty.max_nesting_depth`: `Referent.to_yaml()` (`Representamen` 输出) 默认的最大递归显示层数约束。默认为 `1`。
    -   `Config.安全等级`: 当前安全等级约束。默认为`high`以避免在工作场合出现不适宜内容。需要使用`force`修改。
    -   `Config.arena_format`: `Commonspace` 交互环境格式 (`Representamen`) 的约束。当前可选 `"Canvas"`, `"Tracer"` 等。默认为 `"Canvas"`。
    -    `Config.CommonspaceLog.level`: `CommonspaceLog` 的日志等级。
    -    `Config.default_chat_to`: 全局 chat 命令的默认对象。

-   **方法**:
    -   `Config.to_yaml()`: 以 YAML 格式 (`Representamen`) 输出当前所有配置项（约束）。


### 5.3. `cts`

`Dict[Cognitor.name, List[CT]]`

- **作用**: 一个指向当前所有 认知轨迹 (`Representamen` 集合) 的对象句柄 (`Representamen`)。

### 5.4. `cognitors`

`Set[Cognitor]`

- **作用**: 一个存放当前所有参与 `Commonspace` 的 `Cognitor` 的集合。
