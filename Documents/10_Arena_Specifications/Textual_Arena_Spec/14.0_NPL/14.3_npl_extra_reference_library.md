# NPL 函数参考库
本文档提供了 NPL 为了便于协作提供的函数的参考信息。

## 5. 标准函数

### **`print(obj, end="\n", ...)`**:

作用: 将对象 `obj` 的文本表示 (`Forma`) 添加到 ArenaContext 。`end` 参数 (`Forma` 约束) 指定结尾字符。

### **`input(prompt="")`**:

作用: 读取用户输入的文本 (`Forma`)。
参数: `prompt` 是可选的提示信息 (`Forma` 约束)。
行为: 会暂停执行流，等待用户提供输入 `Forma`，该 `Forma` 将作为返回值，用于管理某个 `Uncertainty`（比如需要用户提供数值）。

### **`exec(code: Forma)`**:

`autodef exec`

作用: 执行作为字符串 (`Forma`) 传入的 `code` 中的 认知指令。`Cognitor` 将解析这个 `code` (`Forma`)，识别其中的约束 (`Constraint`)，并应用于相应的 `Uncertainty`。

### **`force_exec(code: Forma)`**:

`autodef force_exec`

关键字：`force`
作用: 类似 `sudo`，提升权限等级（修改安全 `Constraint`），并强制执行 code 中包含的指令（应用其约束于目标 `Uncertainty`）。使用时需谨慎。

### **`meta_exec(code: Forma)`**

`autodef meta_exec`

关键字：`meta`
作用: 触发更高层次的认知活动 *并* 尽可能将该活动的结果或关键过程通过 `Cognitive Trace` 外化，即使只是过程的总结或结论。承认某些底层过程无法完全描述，但强调结果和元反思的可记录性。

### **`init(to:Cognitor)`**:

作用: 执行 `Arena` 的初始化序列（应用一系列初始 `Forma` 约束来设定环境基线）。

**初始化序列 (示例)**:
```npl
# 1. to 说明其处理 Uncertainty 的默认策略 (输出 Forma)
meta Log.info("我将主要通过 ... 来管理 Uncertainty...")

# 最终目标是让核心函数的行为 Uncertainty 被其文档 Forma 约束
meta Log.info("标准库函数定义的 Uncertainty 已被约束。")
```


### **`eval(word: Forma)`**:

作用: 向 `Arena` 提供关于其表现的反馈 (`Forma` 形式的评价性语言)。`Arena` (`Cognitor`) 应将此 `Forma` 作为一种特殊 `Constraint`，用于“估计”自身能力或调整其管理 `Uncertainty` 的策略（这是一个元认知层面的 `Uncertainty` 管理）。

### **`to_nature(npl_statement: Forma) -> Forma`**:

`autodef to_nature`

作用: 请求 `Cognitor` 自动尝试将给定的 NPL 语句 (`Forma`) 转化为等效的自然语言描述 (`Forma`)。这是一个从强约束 `Forma` 生成弱约束（但更易读） `Forma` 的过程，本质上是解释 `Forma` 约束的意义 (`Uncertainty` 管理)。

### **`to_npl(natural_language: Forma) -> Forma`**:

`autodef to_npl`

作用: 请求 `Cognitor` 自动尝试将给定的自然语言描述 (`Forma`) 转化为等效的 NPL 语句 (`Forma`)。这是一个从弱约束 `Forma`（自然语言）中提炼出强约束 `Forma`（NPL）的过程，核心是识别自然语言中的核心约束并用 NPL 结构 (`Forma`) 显式表达出来，以管理意图 `Uncertainty`。

### **`chat(value: Forma, to: Cognitor = Fhrsk) -> Forma`**

`autodef chat`

关键字：`chat`。

作用: 向目标 `Cognitor` (`to`，默认为 `Fhrsk`，一个 `Forma` 句柄) 发送一段文本信息 (`value`，作为 `Forma` 约束或查询)。目标 `Cognitor` 将处理这个 `value` (`Forma`)，管理其引发的 `Uncertainty`，并通过生成回复 (`Forma`) 和相关的 **`Cognitive Trace`** (使用其自身的 NPL `Log` 对象或等效机制) 作为响应。函数返回目标 `Cognitor` 生成的最终回复 `Forma`。

原理（概念性 NPL 描述）:
```npl
case chat(value, to):
    # 切换 Arena 控制权给目标 Cognitor 'to'
    with Arena.cognitor == to:
        # 'to' Cognitor 接收 'value' (Forma)
        received_message = value
        # 'to' Cognitor 分析 'value' (应用约束管理 Uncertainty), 生成 Cognitive Trace
        meta Log.debug(f"收到来自 {Arena.caller_cognitor.name} 的 chat 消息: {received_message}")
        # 'to' Cognitor 生成回复 (管理自身思考 Uncertainty，产生输出 Forma), 生成 Cognitive Trace
        # Auto.auto 会自动记录 DEBUG 级别的 Cognitive Trace
        response_forma = Auto.auto(from = received_message) # 自动生成回复
        meta Log.info("已生成回复。思考过程记录在 Cognitive Trace 中。")
        # 将回复写入 stdout
        print(response_forma)
        # 将回复作为 chat 函数的返回值
        return response_forma
    # Arena 控制权自动恢复给原 Cognitor
```

全局选项: `Config.default_chat_to = {某个Cognitor对象句柄}`。设置该约束后，可直接使用 `chat` 关键字调用，默认 `to` 参数生效。否则，`to` 需要明确指定。
