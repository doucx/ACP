# NPL 日志条目格式参考

本规范定义了 NPL 中 认知轨迹 (`Cognitive Trace`) 的 `Log` 实现 的条目的推荐结构，旨在同时适应人类 Cognitor 的输入习惯和当前主流 LLM Cognitor 的实际输出特性（如倾向于自然语言叙述、难以提供精确内部状态、可能存在幻觉等），同时保持足够结构化以供分析。这些条目是核心协议中 `Cognitive Trace System` 在 Canvas 环境下的具体体现。

## 日志条目结构

每个日志条目应包含以下字段：

1.  **`type`** (Enum, **必需**)
    *   日志类型，`NPL`，`TRACE`，`INFO`，`ARENA`。

2.  **`originator`** (String, **必需**)
    *   产生此日志的 实体 的唯一标识符。
    *   *示例:* `"ChatGPT-XYZ123"`, `"Alice"`, `"Python-310"`

3.  **`message`** (String, **必需**)
    *   日志的最重要的核心内容。
    *   对于 Cognitor，此字段预期主要是**第一人称自然语言文本**。 它应该尽可能真实地记录 Cognitor 自己提供的“思考”或说明。

4.  `seq` (String, **可选**)
	- 当前日志在同层级日志中的序号。便于对日志的引用。

5.  **`log_entry_type`** (Enum, **推荐**, 可选, 可多个)
    *   提供日志内容的语义分类，帮助理解条目意图。推荐值包括：
        *   `Observation`: 记录观察到的事实、数据或外部事件。
        *   `ActionPlan`: 描述计划执行的动作或 NPL 语句。
        *   `Interpretation`: 对观察结果或信息的解读。
        *   `Hypothesis`: 提出的假设或可能性。
        *   `ReasoningNarrative`: 以自然语言形式叙述的思考过程、推理链或分析步骤。这是容纳“口语化”输出的核心类型。
        *   `DecisionRationale`: 为作出的某个决策提供的理由。
        *   `SelfCorrection`: 对先前错误认知的修正记录。
        *   `ConfidenceReport`: 对某结论或过程的置信度的主观陈述（通常需要被提示或自愿提供）。
        *   `MetaDataChange`: 记录配置变更等元数据事件。
        *   `ExternalInput`: 记录通过 `input()` 等方式获取的外部输入。
        *   `ToolOutput`: 记录调用外部工具（Function Call）的返回结果。
        *   `Annotation`: 对其他日志条目添加的元注释。
        *   `SystemEvent`: Arena 内部事件
    *   同时，也可以依照需求自定义。

注：使用了`seq`代替了难以由`Cognitor`获取的`timestamp`。

具体日志示例：

ACP Canvas：
```xml
<log originator="Fhrsk" type="INFO" seq="42">
  <message>
	总之，我意识到需要获取用户位置信息，我需要询问用户所在城市。
	接下来，我将创建一个 EXEC Node ，并直接询问用户所在城市来获取用户城市信息。
  </message>
  <log_entry_type value="ReasoningNarrative"/>
</log>
```

ACP Tracer ：
```
(Fhrsk)INFO[42]: 
总之，我意识到需要获取用户位置信息，我需要询问用户所在城市。
接下来，我将创建一个 EXEC Node ，并直接询问 "你在什么城市" 来获取用户城市信息。[ReasoningNarrative]
```

## 设计考量与应用

*   **拥抱自然语言:** `message` 字段优先考虑容纳 Human 和 LLM 自然产生的语言表达。这也是日志最重要的部分。
*   **区分来源与意图:** `originator` 区分了是谁此时在修改 Arena，`log_entry_type` 帮助理解他/它想表达什么。
*   **处理不确定性与风险:** `flags` 字段提供了一个机制来标记和管理日志信息的不确定性，特别是针对 LLM 的潜在幻觉问题。
*   **灵活性:** 该格式旨在提供一个通用框架，具体的 `log_entry_type` 可以根据应用场景进行扩展。