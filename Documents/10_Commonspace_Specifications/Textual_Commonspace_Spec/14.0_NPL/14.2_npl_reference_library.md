#  核心概念交互参考

## 1. `Representamen` (确定性实体)

`Representamen` 直接基于 `Space` 存在，它不需要使用 `print` 等方法输出来显示其内容。对它的创建本身就已经在 `Space` 中显示了。见 [[12_protocol_requirements]]。

而 `Representamen`（作为一种类型）用于在 NPL 中，标记函数的输出将由 `CT`，`SpaceLog`，`对 Space.context 的添加` 等形式，直接显示在 `Space.context` 中。

可使用 `fo"内容"` 来标记一段字符串被作为 `Representamen` 处理。

由于字符串，列表等类型的数据结构都由 Cognitor 模拟，包含 `Referent`，因此都不被视为 `Representamen`。

方法：

-   **`__uncertainty__()`**:
    -   签名: `forma_instance.__uncertainty__ -> Referent`

	-   作用: 获取一个 `Referent` 句柄，该句柄指向与“重新解读此 `Representamen` (文本内容) 在当前上下文中可能产生的**意义不确定性**”相关联的 `Referent` 状态。原 `Representamen` 的内容成为这个新 `Referent` 的一个初始的、强有力的**约束 (`Constraint`)**。这允许 `Cognitor` 对一个已经确定的形式进行二次审视和意义探索。

    -   示例（概念性）：对于 `Representamen` 实例 `my_number = 5` (文本"5")，执行 `Referent(my_number)` 得到一个 `Referent` 句柄，`Cognitor` 可以开始思考“这个'5'代表什么？” (通常能够根据 `my_number =` 直接判断出 `5` 的类型是 `int` )，而"5"这个文本 `Representamen` 本身是其核心 `Constraint`。

-  **`__repr__() -> Quote`**
	- 因为 `fo""` 的内容已经在输入后就存在于 Space 中了。为了降低冗余，如果试图重复输出一个 `Representamen`（如 `print` ， `ct` 等方法），会产生一个 `Quote` 。
	- 如（概念性示例）：
		- Alice 输入了 `a = fo"这创建了一个对该 Representamen 的引用。"`，执行 `print(a)` 输出 `Quote: { creater=Alice, "这创建...引用" }`。


## 2. `Referent` (不确定性实体)

在 NPL 中，指向一个 `Referent` 的 `Representamen` 句柄。见 [[12_protocol_requirements]]

代表需要 `Cognitor` 进行认知处理以确定其意义或具体内容的**不确定性状态**。在 Textual Space 中，这通常指代由一段文本 (`Representamen`) 引发的意义可能性空间。

可使用 `Referent` 或 `U` 调用 `Referent` 类。

属性：

-    `cognitor: Cognitor`: 
	- 只读，用于标记这个 `Referent` 是谁管理的。代表第一次操作它的 操作者。

-    `constraints: list[Referent]`: 
	- 存放添加了的约束。

方法：

-    `add_constraint(CD: Representamen|Referent)`: 
	- 为该 `Referent` 添加一个约束。处理顺序（概念性）：
		1. `CD` 如果是 `Referent`，则不变，否则将被转化为 `CD: Referent`。
		2. 如果 `CD: Referent` 可以被 `Cognitor` 理解，则跳至 `4`。
		3. CD.add_constraint(auto 额外信息) （此处会产生递归）
		4. `Cognitor` 基于其语言理解能力来解读这个 `CD: Referent` 约束并将其添加到 `self.constraints` 中。

-    `get_constraints(CD) -> List[Representamen]`: 
	- 获取 `add_constraint` 过程中施加在该 `Referent` 上的所有 `Representamen` 约束列表。

-   **`__forma__(self, ...)`**:
    -   作用: 请求 **`Cognitor`** 基于预定义的转换规则（通常由 `Cognitor` 根据上下文自动推断）和所有已应用的 `Representamen` 约束，将这个 `Referent` **尽可能地解析和固化为一个确定性实体** (`Representamen`)。这是 `Cognitor` 在应用所有约束后，做出最终判断或创建确定性输出的动作。

-   **`__call__(self, CD: Representamen)`**:
    -   作用: 将该 `Referent` 视为一个可调用的函数，进行调用。如 `分析(苹果)` 。

-   **`fill()`**:
    -   作用: 这是一个**请求 `Cognitor` 动用其核心认知能力**的操作。`Cognitor` 需要评估当前 `Space.context` (整体上下文 `Representamen` 作为隐式 `Constraint`) 以及 `self.constraints` 中所有约束内容，利用 `Cognitive Trace`， 对该 `Referent` 句柄指向的不确定性状态进行**深度理解、推理和信息补全**，尝试**最大限度地消解其模糊性**，使其意义在当前上下文中更加明确。这是一个依赖 `Cognitor` 应用约束能力的**解释和精化过程**。

-   **`yaml(max_nesting_depth=..., mode=..., ...) -> Representamen`**:
    -   作用: 以 YAML 格式 (`Representamen`) 输出该 `Referent` 的结构化描述，包括其当前状态和已应用的约束，可控制递归深度和模式。

-   **`pick(num=1, ...)`**:
    -   作用: 请求 **`Cognitor`** 从该 `Referent` 句柄所代表的**多种可能性意义**中，根据当前所有 `Representamen` 约束（显式和隐式），提取出 `num` 种**最具代表性或差异性的具体解读**。这些解读通常以 `Representamen` (如具体的文本描述或数值) 或更具体的 `Referent` 描述形式返回。

## 3. `Cognitor` (认知实体)

指向 `Cognitor` 信息的 `Representamen` 句柄。

属性：
-   **`info`**:
    - 作用：指向 `CognitorInfo` 中该 `Cognitor` 的 `yaml` 格式的信息。

-    **`default_chat_to`**:
	- 作用：设置 `chat` 的默认行为。

-   **其余属性**:
	* 与 `self.info` 中的结构相同，如 `Cognitor.name` 等。

方法：
-    **exec(CD: Representamen)**:
	* 作用: 在该 `Cognitor` 的上下文中执行认知指令。所有的 NPL 都需要通过该方式执行。

## 4. Space (认知空间)

指向 Space 元信息的 `Representamen` 句柄。

属性：

- **`operator: Cognitor`**
	- **类型**：动态占位符（Placeholder）
	- **作用**：
	  - 被调用时，`Space.operator` 指向的是 **当前操作 `Space` 的 `Cognitor`**。
	    - 具体来说，当某个 `Cognitor` 获取 `Space` 时，`Space.operator` 会自动更新为该 `Cognitor` 的身份。
	  - 这种机制确保了 `Space.operator` 始终反映最新的调用者信息，而不是固定的创建者信息。用来标识“当前是谁在操作”。

- **`context: Quote`**
	- **类型**：引用（Quote）
	- **作用**：
	  - 被调用时，作为对创建该指令时`SpaceContext`的引用。

方法：

- **`release([cognitor: Cognitor])`**:
	- **作用**：
	  - 被调用时，要求 `Space.operator` 释放 `Space`。如果 `cognitor` 被设置，`cognitor` 将会成为 操作者。否则，将由 cognitors 竞争。
	  - 使用 `with Space.release()` 临时释放 `Space`，保证在结束后自己重新成为 操作者。

对 `Space` 的获取将由 `Cognitor` 自行决定，遵从先来后到的规则。


## 5 Cognitive Trace System（认知轨迹系统）

#### **简介**  
`Cognitive Trace System`（CT 系统）是 **`Cognitor`**（认知实体，包括人类或程序化执行器）的行为记录规范，用于在 **`Space`** 中创建描述其认知过程的 **`Representamen`** 条目。所有认知轨迹由 `Cognitor` 自主判断并动态创建，形成可追溯的逻辑链条。  

- **`CT`**（Cognitive Trace）：认知轨迹的**通用类型**，表示 `Cognitor` 在 Space 中创建的任意一条认知行为记录。

- **`ct`**：用于**声明认知轨迹关注点**的工具对象，开发者通过它向 `Cognitor` 提示需要重点记录的代码范围（但最终是否记录仍由 `Cognitor` 自主决定）。

---

#### **核心特性**  
1. **类型化记录**  
   - 认知轨迹仅通过**类型**（`TRACE`/`THINK`/`SAY`/`SPACE`）区分行为性质，**不存在“级别”概念**。  
   - **不可省略任何类型**：所有 `Cognitor` 行为均需根据其语义创建对应类型的轨迹条目。  

2. **自主性控制**  
   - **默认行为**：`Cognitor` 根据上下文自动判断是否创建轨迹条目及类型，无需人工干预。  
   - **声明式提示**：通过 `with ct.<类型>` 语法向 `Cognitor` **提示**需关注的场景，但最终是否创建条目仍由其自主决定。  
     ```npl  
     # 提示 Cognitor 在此代码块中需关注 TRACE 和 THINK 类型的轨迹  
     with ct.trace, ct.think:  
         result = 计算权重()  # Cognitor 可能创建 TRACE 或 THINK 条目（但非强制）  
     ```  

3. **引用优化**  
   - 在 `TRACE` 类型中，通过 **`Quote`** 引用已有 `Representamen`，避免冗余内容重复记录。  

---

#### **类型定义**  
| 类型       | 用途                                                                 | 创建条件（由 Cognitor 判断）                 |  
|------------|----------------------------------------------------------------------|--------------------------------------------|  
| **`TRACE`** | 描述 **当前执行的认知指令**（自然语言或 NPL 片段）                     | 当执行关键逻辑时自动创建。       |  
| **`THINK`** | 描述 **内部推理过程**（如决策依据、逻辑链、思维链）                            | 当进行复杂计算、策略选择或异常处理时自动创建。 |  
| **`SAY`**   | 描述 **对外表达的自然语言内容**（如用户提示、交互反馈）                | 当向外部实体（如用户、其他系统）输出时自动创建。 |  
| **`SPACE`** | 描述 **对 Space 的操作**（如获取/释放、路由）                  | 当操作 Space 时自动创建。   |  

---

#### **使用规范**  
1. **禁止直接操作**  
   - **不可手动调用**如 `ct.say("内容")` 或 `ct.trace(...)`，所有条目由 `Cognitor` 自主创建。  

2. **声明式提示示例**  
   ```npl  
   # 提示 Cognitor 关注此代码块的 TRACE 和 SPACE 类型轨迹  
   with ct.trace, ct.arena:  
       chat 你好 # Cognitor 可能创建 TRACE（指令执行）和 SPACE（资源操作）条目  
   ```  

3. **引用优化示例**  
   ```npl  
   # 通过 Quote 减少重复内容  
   with ct.trace:  
       ... # 很长一段指令
       # Cognitor 可能创建 TRACE 条目并通过 Quote 引用该指令
   ```  

---

#### **设计原则**  
- **自主性**：`Cognitor` 全权控制轨迹的创建逻辑，人类仅提供语义提示。  
- **完整性**：覆盖认知过程的所有关键行为类型，无过滤机制。  
- **轻量化**：通过引用和结构化描述降低存储冗余。  