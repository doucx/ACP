# 内置类

## 1 `Auto`

`Auto` 类是 NPL 中**直接调用和引导 `Cognitor` 核心认知能力**（特别是推理和创建能力）的主要接口。它的核心机制在于将用户提供的**认知指令**（无论是自然语言描述 (`Representamen`) 还是结构化条件 (`Representamen`)）**视为施加于某个潜在 `Referent` 上的复杂约束 (`Constraint`) 或处理目标**。`Auto` 方法会结合当前的 `Space` (作为隐式 `Representamen` 约束)，然后**请求 `Cognitor` 调用其能力**，尝试应用这些约束来管理目标 `Referent`，并将其转化为一个相对确定的 `Representamen` 或更明确的 `Referent` 状态（例如，创建一段 NPL 代码 `Representamen`、填充对象属性 `Representamen`、执行一个推断出的操作）。

为了记录 `Cognitor` 在响应 `Auto` 请求时如何应用约束和管理 `Referent` 的过程，使用任何 `Auto` 类的方法**通常会产生大量 `Cognitive Trace` **。

`from` 参数提供一段文本 (`Representamen`) ，作为额外的显式**约束 (`Constraint`)**，用于**引导 `Cognitor` 的理解和创建方向**。

-*"常识"的定义**  
常识包含三类信息：  
1. 当前ACP文档内容  
2. Space 的内容  
3. 当前对话中已建立的共识  

这些内容需满足：  
- 具有普遍性（非特定Cognitor的专有知识）  
- 已成为 Representamen
- 经Cognitor判断在当前语境下具有高可信度和适用性  

#### **`Auto.autodef(target: Representamen, from: Representamen = 常识, ...)`** :

-   作用: 请求 **`Cognitor`** 自动为 `target` (`Representamen`，描述概念的文本) 创建定义。`Cognitor` 会将 `target` 视为指向“需要定义什么”的 `Referent` 的核心约束，并以 `from` 指定的文本 (`Representamen`) 作为额外的知识来源和约束，运用其**理解和创建能力**，尝试管理这个 `Referent`，最终创建一个能代表该定义的、结构化的 `Representamen`（如类结构）或一段更详细的说明性文本 (`Representamen`)。
-   关键字: `autodef`

#### **`Auto.autofill(target: Representamen, from: Representamen = 常识, ...)`** :

-   作用: 请求 **`Cognitor`** 自动填充由 `target` (`Representamen`，描述对象、概念或结构的文本) 所代表的内容中不确定的部分。`Cognitor` 会将 `target` 的待填充状态视为包含了需要管理的 `Referent`（“缺失的信息是什么？”）。它从 `from` (`Representamen`，通常是包含相关信息的描述性文本) 提供的约束和信息中提取细节，运用其**理解和关联能力**，尝试填充 `target` (`Representamen`) 的表示，管理 `Referent`，使其成为一个属性更明确、内容更完整的 `Representamen` 或细化的文本描述 (`Representamen`)。整个应用约束、管理 `Referent` 的过程需要被详细地记录在**`Cognitive Trace`** 中。
-   关键字: `autofill`

#### **`Auto.autolet(cond: Representamen, target: Representamen = auto, from: Representamen = 常识, 原则: Representamen = 最小修改, ...)`** :

-   作用: 请求 **`Cognitor`** 自动施加约束以满足特定条件。`Cognitor` 会将 `cond` (`Representamen`，描述所需条件或状态的文本) 理解为目标状态，即一个强约束 (`Constraint`)。然后，它会分析 `target` (`Representamen` 句柄，指向需要被约束的状态或对象及其关联的 `Referent`)。基于 `from` (`Representamen` 约束) 提供的上下文和 `原则` (`Representamen` 约束，描述调整策略) ，`Cognitor` 运用其**推理和规划能力**，调整与 `target` 关联的状态表示 (`Representamen`)，应用约束管理 `Referent`，使其最终满足 `cond` (`Representamen` 约束) 所描述的条件。
-   关键字: `autolet`

#### **`Auto.auto(from: Representamen = 常识, ...)`** :

-   作用: 请求 **`Cognitor`** 进入最高级别的自主模式。这代表了一个高度开放的请求，将当前的主要 `Referent`（通常是“接下来应该做什么？”）交由 `Cognitor` 处理。`Cognitor` 被要求运用其**最高级别的理解、推理、规划和执行能力**，根据 `Space` (整体 `Representamen` 作为隐式约束) 和 `from` (`Representamen` 作为额外的显式约束或提示) 提供的所有约束，**自主猜测用户最可能的意图（形成内部目标 `Representamen`，即对核心 `Referent` 的一种解读）**，并自动规划和执行其推断出的最合适的操作序列（内部通过管理 `Referent` 和创建 `Representamen` 进行思考和决策），尝试达成一个对用户有价值的确定的结果 (`Representamen` 输出或状态改变，并通过输出 `Representamen` 报告）。
-   关键字: `auto`

## 2 Quote（引用）

#### 作用  
`Quote` 是一种用于减少 `Space` 中重复 `Representamen` 的机制，通过引用已有 `Representamen` 来降低Space中的冗余。  

#### 核心属性  
一个 `Quote` 可能包含以下信息，以确保能唯一标识被引用的 `Representamen`：  
1. **唯一序号**（Unique ID）  
   - 用于精确匹配被引用的 `Representamen`（如 `cts[Cognitor.name][X]`）。  
2. **创建者**（Originator）  
   - 标识该 `Representamen` 的原始创建者。  
3. **简略内容**（Summary）  
   - 提供可读的摘要，便于快速识别（如关键字段或特征）。  
4. **其它定位方式**（Alternative Locators）  
   - 如路径、URI、逻辑坐标等，支持灵活检索。  

#### 方法


#### 设计原则
- **唯一性**：通过组合属性（如 `创建者+ID`）确保引用精准。
- **轻量化**：存储引用而非完整 `Representamen`，降低书写开销。
- **可追溯性**：支持通过 `Quote` 反向查询原始 `Representamen` 的完整内容。

#### 适用场景
- 在`CT`中复用同一 `Representamen`。