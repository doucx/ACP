# NPL 内置“库”：高级认知引导模式

**重要前提**: 本文档描述的“库”（如 `SpaceLog`, `AutoGuidance`）及其函数，**不是**传统意义上的可执行代码库。它们代表了 NPL 中预定义的、用于实现特定协作目的的**高级认知引导模式**。调用这些“函数”是在 NPL 中对 `Cognitor` 发出结构化的、包含特定意图的**认知指导**，请求 `Cognitor` 运用其相应的认知能力来完成特定任务。

## 1. `SpaceLog`: 引导记录日志信息的模式

* **目的**: 提供一种标准化的方式来**指导 `Cognitor`** 在其 `Cognitive Trace` (`CT`) 中记录特定类型和重要性的信息，类似于传统日志，但最终记录在 `CT` 中。
* **引导模式 (NPL "函数")**:
    * **`SpaceLog.debug(message: Datum)`**: 指导 `Cognitor` 创建一条 `CT` 条目，标记为低优先级/调试信息，内容为 `message` 所代表的 `Representamen`。
    * **`SpaceLog.info(message: Datum)`**: 指导 `Cognitor` 创建一条 `CT` 条目，标记为一般信息。
    * **`SpaceLog.warning(message: Datum)`**: 指导 `Cognitor` 创建一条 `CT` 条目，标记为警告信息。
    * **`SpaceLog.error(message: Datum)`**: 指导 `Cognitor` 创建一条 `CT` 条目，标记为错误信息。
    * **`SpaceLog.critical(message: Datum)`**: 指导 `Cognitor` 创建一条 `CT` 条目，标记为严重错误信息。
* **`Cognitor` 响应**: 接收到 `SpaceLog` 指导后，`Cognitor` 应：
    1.  理解指导意图（记录特定级别的信息）。
    2.  获取 `message` `Datum` 的内容。
    3.  创建一条新的 `Cognitive Trace` (`CT`) 条目。
    4.  在该 `CT` 条目的 `message` 字段中包含信息内容。
    5.  在该 `CT` 条目的 `tag` 字段中添加相应的级别标记（如 `LogLevelDebug`, `LogLevelInfo` 等）以及可能的其他相关标签。
    6.  将此 `CT` 追加到 `Space`。
* **与 `CT` 的关系**: `SpaceLog` **不是**一个独立的日志系统，它是**指导 `Cognitor` 如何使用 `CT` 系统**来记录特定运行信息的**约定模式**。所有日志信息最终都成为 `Space` 中 `CT` 流的一部分。日志级别可以通过 `Config.SpaceLog.level` 指导 `Cognitor` 过滤其**生成**哪些级别的 `CT` 条目。

* **NPL 伪实现示例**:
    ```npl
    # 指导模式定义: SpaceLog.info(message)
    def SpaceLog.info(message_datum):
        # 指导 Cognitor: 创建 CT
        ct_entry = CT.new(originator=operator) # 指导创建 CT 对象句柄
        ct_entry.set_type("THINK") # 指导设置类型 (或 TRACE, 取决于上下文)
        ct_entry.set_message(message_datum.get_text()) # 指导设置消息内容
        ct_entry.add_tag("LogLevelInfo") # 指导添加级别标签
        # 指导将 CT 追加到 Space (这是 Cognitor 的基本能力)
        Space.append(ct_entry)
    ```

## 2. `AutoGuidance`: 请求高级认知能力的引导模式 

* **定位**: `AutoGuidance` **不是**一个具有自主能力的实体或库。它代表了一组**高级认知引导模式**，用于**请求 `Cognitor` 运用其内在的核心认知能力**（如推理、规划、生成、知识关联、上下文理解等）来处理复杂的、可能定义不够明确的任务。它是一种**将高层意图传递给 `Cognitor` 的结构化方式**。
* **核心机制**: 调用 `AutoGuidance` 模式时，提供的参数（如 `target`, `from`, `cond`）被视为施加于某个潜在**参照物 (`Referent`)** 上的复杂**约束 (`Constraint`)** 或处理目标。该模式**指导 `Cognitor`**：
    1.  **理解高层意图**: 解析 `AutoGuidance` 指令，识别其核心目标（如“定义概念”、“填充信息”、“满足条件”、“自主行动”）。
    2.  **整合约束**: 结合指令中提供的显式**约束** (`from` 参数等) 和 `Space` 的隐式**上下文约束**。
    3.  **调用核心认知能力**: 激活其内部相应的认知模块（推理、生成、规划等）来处理目标 `Referent`，管理其不确定性。
    4.  **生成结果**: 尝试将 `Referent` 转化为一个相对确定的结果（可能是新的 `Datum`，如一段 NPL 代码、填充的对象描述；也可能是 `Space` 状态的改变；或者仅仅是详细的 `CT` 分析）。
    5.  **记录详细 `CT`**: 由于这类指导涉及复杂的内部认知过程，`Cognitor` **必须**产生大量、详细的 `Cognitive Trace` (`CT`) 来记录其如何理解指令、应用约束、进行推理、处理 `Referent` 并得出结果。
* **与“猜测”的关系**: `AutoGuidance` 模式确实依赖于 `Cognitor` 基于上下文进行“猜测”或“最佳推断”的能力，但这并非魔法。它是对 `Cognitor` **已知（通过训练或设计）具备的认知推理和生成能力的结构化调用请求**。`Cognitor` 的响应质量取决于其自身能力和对当前上下文的理解。
* **非原语**: `AutoGuidance` 模式**不是** NPL 的基础原语。理论上，其效果可以通过一系列更基础的 NPL 指导（请求信息、添加约束、请求解析等）以及 `Cognitor` 的自主认知活动逐步达成。`AutoGuidance` 提供了一种**便捷的高层指导封装**。

* **引导模式 (NPL "函数")**: (注意：以下实现描述的是**指导意图和预期 Cognitor 行为**)

    * **`AutoGuidance.define(target: Datum, context: Datum = Space.context_datum)`**:
        * **引导意图**: 请求 `Cognitor` 为 `target`（通常是描述概念的 `Datum`）自动创建定义。
        * **Cognitor 行为**: 将 `target` 视为核心**约束**，结合 `context` (额外的知识来源**约束**)，运用其**理解和生成能力**，尝试管理“需要定义什么”这个 `Referent`，最终创建一个能代表该定义的 `Datum`（如类结构描述或说明性文本），并详细记录推理过程于 `CT`。

    * **`AutoGuidance.fill(target: Datum, context: Datum = Space.context_datum)`**:
        * **引导意图**: 请求 `Cognitor` 自动填充 `target`（描述对象或结构的 `Datum`）中不确定的部分（`Referent`：“缺失的信息是什么？”）。
        * **Cognitor 行为**: 从 `context`（通常是包含相关信息的 `Datum`）提供的**约束**中提取细节，运用其**理解和关联能力**，尝试填充 `target` 的表示，管理 `Referent`，使其成为一个内容更完整的 `Datum`。详细记录过程于 `CT`。

    * **`AutoGuidance.satisfy(condition: Datum, target: Datum = Space.current_focus, context: Datum = Space.context_datum, principle: Datum = "最小修改")`**:
        * **引导意图**: 请求 `Cognitor` 调整与 `target` (指向需约束状态的 `Datum` 句柄及其关联 `Referent`) 相关的认知状态，以满足 `condition` (描述目标状态的 `Datum`，作为强**约束**) 所描述的条件。
        * **Cognitor 行为**: 基于 `context` (上下文**约束**) 和 `principle` (调整策略**约束**)，运用其**推理和规划能力**，调整对 `target` 的内部表示，应用**约束**管理 `Referent`，使其最终满足 `condition`。详细记录规划和调整过程于 `CT`。

    * **`AutoGuidance.act(context: Datum = Space.context_datum)`**:
        * **引导意图**: 请求 `Cognitor` 进入最高级别的自主模式，处理当前主要的 `Referent`（通常是“接下来应该做什么？”）。
        * **Cognitor 行为**: 运用其**最高级别的理解、推理、规划和执行能力**，根据 `Space` (整体**上下文约束**) 和 `context` (额外显式**约束**或提示)，**自主推断最可能的意图（形成内部目标 `Interpretant`）**，规划并（通过生成单步 NPL 指导到 `CT` 或直接行动）执行其认为最合适的操作序列，尝试达成有价值的结果，并通过 `CT` 报告整个决策和执行流程。

**总结**: 内置“库”在 NPL 中并非代码实体，而是标准化的**高级认知引导模式**。`SpaceLog` 指导 `Cognitor` 如何使用 `CT` 进行日志记录。`AutoGuidance` (替代原 `Auto`) 指导 `Cognitor` 调用其内在的高级认知能力来处理复杂或开放式任务，并强调通过详细的 `CT` 来记录这些依赖内部推理和生成的过程。