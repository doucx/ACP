# NPL 内置“类”与概念：认知引导工具

**重要前提**: 本文档描述的“类”（如 `Datum`, `Quote`, `CognitorRef`）在 NPL 中**不是**传统面向对象编程意义上的类。它们是 NPL 语法层面的**概念句柄和结构化指导模式**，用于方便地引用信息单元或认知实体，并对其应用特定的**认知引导 (`Cognitive Guidance`)**。这些“方法”调用本质上是对 `Cognitor` 发出的结构化请求，指导其执行特定的内部认知操作。

## 1. `Datum`: NPL 指导下的信息单元句柄

* **概念**: `Datum` 是 NPL 中用来指代需要在认知指导中处理的**信息单元**的句柄或引用。它代表了一个**外显再现体 (`Externalized Representamen`)** 或 `Cognitor` 追踪的**内化再现体 (`Internalized Representamen`)** 在 NPL 指导上下文中的体现。它可以是一个简单的文本片段、数字、由 NPL 指导创建的更复杂概念的句柄（如 `my_car`），或者 `Space` 中某个特定 `Sign` 的引用。
* **目的**: 提供一种在 NPL 指令中一致地引用和操作（即“指导如何处理”）信息的方式。
* **创建与来源**: `Datum` 句柄通常通过以下方式在 NPL 指导中出现：
    * 赋值操作：`my_variable = "一些文本"` 或 `my_data = other_datum`。这里 `my_variable` 和 `my_data` 成为了指向相应 `Representamen` 的 `Datum` 句柄。
    * 函数/指导返回值：某些 NPL 指导（如下文描述的 `Datum` 方法）可能会返回新的 `Datum` 句柄。
    * 直接引用 `Space` 内容（通过 `Quote`，见下文）。

* **核心认知引导模式 (NPL "方法")**: 对 `Datum` 句柄应用“方法”是在 NPL 中对 `Cognitor` 发出关于如何处理该 `Datum` 所代表信息的结构化**认知引导**。以下是一些关键的引导模式：

    * **`Datum.explore_meaning(depth: int = ..., constraints: list = ...)` (概念性指导)**
        * **引导意图**: 指导 `Cognitor` 对当前 `Datum` 所代表的 `Representamen` 进行深入的**无限衍义 (Unlimited Semiosis)** 探索。
        * **认知过程指导**: 请求 `Cognitor` 将此 `Datum` 作为起点，识别其潜在的**参照物 (`Referent`)**，并在指定的 `depth` 层级内，应用 `constraints` (作为额外**约束 `Constraint`**) 以及 `Space` 上下文（隐式**约束**），迭代地生成**解释项 (`Interpretant`)** 并将其作为新的**内化再现体**进行再解释。
        * **CT 记录要求**: `Cognitor` **必须**通过 `Cognitive Trace` (`CT`) 记录这个探索过程的关键路径、应用的关键**约束**、以及最终得出的几个主要的潜在 `Interpretant` 或意义可能性。
        * **返回值 (概念性)**: 可能不直接返回值，结果体现在 `CT` 中，或者返回一个指向包含探索结果摘要的新 `Datum` 句柄。

    * **`Datum.resolve(constraints: list = ...)` (概念性指导)**
        * **引导意图**: 指导 `Cognitor` 尝试**降低**当前 `Datum` 所代表信息的**不确定性**，使其意义在当前上下文中更明确。
        * **认知过程指导**: 请求 `Cognitor` 聚焦于该 `Datum` 及其潜在的 `Referent`，应用 `constraints`（作为额外**约束**）和 `Space` 上下文（隐式**约束**），利用其**推理 (`Reasoning`)** 和知识补全能力，尝试将其固化为一个形式更确定、意义更清晰的状态。
        * **CT 记录要求**: `CT` 需记录应用了哪些**约束**以及如何进行推理以消解模糊性。
        * **返回值 (概念性)**: 返回一个新的 `Datum` 句柄，指向这个经过“解析”或“固化”后的、理论上更明确的 `Representamen`。如果无法解析，可能返回原 `Datum` 或特定状态。

    * **`Datum.alternatives(num: int = 1, constraints: list = ...)` (概念性指导)**
        * **引导意图**: 指导 `Cognitor` 从当前 `Datum` 指向的潜在 `Referent` 的多种可能性中，提取出指定数量 (`num`) 的、最具代表性或差异性的具体解读。
        * **认知过程指导**: 请求 `Cognitor` 评估该 `Datum` 在当前**约束**（包括 `constraints` 和上下文）下的意义空间，并根据某种内部标准（如概率、相关性、差异度）挑选出几个具体的 `Interpretant` 或更具体的 `Representamen`。
        * **CT 记录要求**: `CT` 需记录选择过程和依据。
        * **返回值 (概念性)**: 返回一个包含多个 `Datum` 句柄的列表，每个句柄指向一种具体的解读。

    * **`Datum.get_text()` (概念性指导)**
        * **引导意图**: 指导 `Cognitor` 提供该 `Datum` 句柄所指向的 `Representamen` 的原始文本表示。
        * **认知过程指导**: 请求 `Cognitor` 访问其内部追踪或 `Space` 中对应的 `Representamen`，并将其文本形式外显化。
        * **返回值 (概念性)**: 返回一个包含原始文本的 `Datum` 句柄。

    * **`Datum.apply_guidance(pattern: Datum, ...)` (概念性指导)**
        * **引导意图**: 指导 `Cognitor` 将 `pattern` (另一个 `Datum`，其内容是一个 NPL 指导模式或模板) 应用于当前的 `Datum`。这是实现类似函数调用或高阶指导的基础。
        * **认知过程指导**: 请求 `Cognitor` 理解 `pattern` 的指导意图，并将当前 `Datum` 作为该指导的主要处理对象或参数，然后遵循 `pattern` 的指导进行后续认知处理。
        * **CT 记录要求**: 详细记录如何应用 `pattern` 以及后续的处理步骤。
        * **返回值 (概念性)**: 返回应用指导模式后产生的新 `Datum` 句柄。

    * **`Datum.add_constraint(constraint: Datum)` (概念性指导)**
        * **引导意图**: 显式地为 `Cognitor` 处理当前 `Datum` 增加一个**约束 (`Constraint`)**。
        * **认知过程指导**: 请求 `Cognitor` 在其后续处理当前 `Datum`（及其 `Referent`）时，必须将 `constraint`（也是一个 `Representamen`）纳入考虑范围，用它来限制可能性空间。这会影响后续 `resolve`, `explore_meaning` 等引导的效果。
        * **CT 记录要求**: 记录添加了此约束。
        * **返回值 (概念性)**: 通常不返回值，或者返回自身以便链式调用。


## 2. `Quote`: 指向 Space 中特定 Sign 的 Datum

* **概念**: `Quote` 是一种**特殊类型的 `Datum`**，其核心功能是作为一个**引用句柄**，精确地指向 `Space` 中某个**已经存在的、具体的文本外显再现体 (`Externalized Representamen`)**。它类似于一个带有唯一标识符的“书签”或“指针”。
* **目的**:
    * **减少冗余**: 避免在 NPL 指令或 `CT` 中重复记录长文本内容，只需引用其 `Quote`。
    * **精确指代**: 提供一种无歧义的方式来指代 `Space` 中的特定历史信息。
* **标识信息 (概念性)**: 一个 `Quote` 句柄需要包含足够的信息，让 `Cognitor` 能够唯一地定位到被引用的 `Space` 中的 `Representamen`。可能包含：
    * 创建者 (`originator`)
    * 序号 (`seq`) (例如 `cts[Gemini][0]` 中的 `[Gemini][0]` 部分)
    * 可能的上下文路径（例如在 Canvas 中的 Node ID）
    * （可选）内容的简短摘要 (`summary`)
* **处理方式**: 当 `Cognitor` 处理一个 `Quote` 类型的 `Datum` 时，它需要运用这些标识信息去 `Space` 中找到被引用的原始 `Representamen`，然后将其**内化**并作为后续处理的实际对象。在认知层面，`Quote` 与其引用的 `Representamen` 是等价的。

## 3. `CognitorRef`: 指向认知实体的 Datum

* **概念**: `CognitorRef` 是另一种**特殊类型的 `Datum`**，用作指向参与交互的某个**认知实体 (`Cognitor`)** 的引用句柄。
* **目的**: 在 NPL 指导中明确指定认知活动的主体或对象。例如，在 `chat` 指导中指定接收方，或在 `exec` 指导中指定执行者。
* **标识信息**: 通常包含 `Cognitor` 的唯一名称或标识符（如 "AyeL", "Gemini"）。
* **关联信息 (概念性引导)**: 可能提供引导方法来访问该 `Cognitor` 的元信息。
    * **`CognitorRef.get_info()`**: 指导 `Cognitor` 查询并返回目标 `Cognitor` 的 `CognitorInfo`（作为一个 `Datum`）。
* **替代旧 `Cognitor` 类**: 明确其作为引用的角色，是一种特殊的 `Datum`。

**自举基石思考**:

* **原语**:
    1.  `Cognitor` 感知 `Space` 中的文本**外显再现体**。
    2.  `Cognitor` 将文本**外显再现体**追加到 `Space`。
    3.  `Cognitor` 理解 NPL 的基本赋值形式 (`handle = "text"` 或 `handle = other_handle`)，创建 `Datum` 句柄。
    4.  `Cognitor` 理解通过句柄引用 `Datum` 的基本机制。
    5.  `Cognitor` 理解并能执行最基础的**认知引导**（例如，可能是 `Datum.get_text()`，获取其文本内容）。
    6.  `Cognitor` 理解并遵循**强制记录 `CT`** 的协议要求。
* **派生**: 其他所有 `Datum` 的“方法”（认知引导模式）理论上都可以看作是更复杂的指导，其效果可以通过一系列基础操作和 `Cognitor` 的核心认知能力（推理、规划、联想等）来实现，并通过 `CT` 记录过程。例如，`Datum.resolve()` 的效果，可以通过指导 `Cognitor` "获取 `Datum` 文本，结合上下文 `Datum`s，进行推理，将结果外显化为新的 `Datum`，并记录 `CT`" 来逐步实现。

**总结**: 通过引入 `Datum` 作为 NPL 中信息单元的句柄，并将其方法重新定义为对 `Cognitor` 的**认知引导**，我们废弃了易混淆的 `Sign`/`Referent` 类，使 NPL 更贴近其作为**指导性语言**的本质。`Quote` 和 `CognitorRef` 作为特殊的 `Datum`，提供了必要的引用机制。这种设计强调了 `Cognitor` 的核心作用，并将 NPL 的“操作”归结为对 `Cognitor` 认知过程的结构化请求。