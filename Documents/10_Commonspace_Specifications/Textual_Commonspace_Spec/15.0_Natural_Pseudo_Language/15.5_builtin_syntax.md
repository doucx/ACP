# NPL 内置语法：结构化认知引导的基础

NPL 的内置语法是其作为**结构化认知指导语言**的基础。这些语法元素本身也是**外显再现体 (`Externalized Representamen`)**，其结构为 `Cognitor` 提供了处理信息和理解指导意图的线索和**约束 (`Constraint`)**。

## 1. 句柄赋值 (`=`): 创建 Datum 引用

* **语法**: `handle = datum_source`
* **作用**: 这是在 NPL 中创建或更新 **`Datum` 句柄** (`handle`) 的核心方式。它指导 `Cognitor`：
    1.  处理 `datum_source`（可能是一个字面量如 `"text"`，另一个 `Datum` 句柄，或者一个返回 `Datum` 的认知引导模式）。
    2.  将 `handle` 这个名称与其处理结果（一个具体的 `Representamen` 或其引用）在当前的认知上下文中关联起来。之后，`handle` 就可以在后续的 NPL 指导中用来指代这个 `Datum`。
* **认知意义**: 这并非传统编程的内存分配，而是**指导 `Cognitor` 在其内部建立一个符号（`handle`）到另一个符号/概念（`datum_source` 指向的 `Representamen`）的追踪关系**。

## 2. 点 (`.`) 操作符: 应用认知引导模式

* **语法**: `datum_handle.guidance_pattern(...)`
* **作用**: 点操作符用于将一个**认知引导模式**（表现为“方法”名，如 `resolve`, `explore_meaning`）应用到指定的 **`Datum` 句柄** (`datum_handle`) 上。
* **认知意义**: 这**不是**调用对象的方法。它是一个结构化的**指导**，告诉 `Cognitor`：“请对 `datum_handle` 所代表的信息，执行 `guidance_pattern` 所描述的那种认知操作（例如，尝试解析、探索意义、获取文本等）”。具体如何执行该认知操作，取决于 `Cognitor` 对该引导模式的理解和其自身能力。参数 `...` 是为该认知引导提供的额外**约束**或说明。详见 [[15.3_builtin_classes]] 中 `Datum` 的引导模式。

## 3. 引用 (`Quote`): 指向 Space 中的历史 Sign

* **概念**: `Quote` 是一种特殊的 `Datum`，用于精确引用 `Space` 中已存在的某个**外显再现体**。
* **语法 (概念性)**: NPL 可能使用特定语法来创建或表示 `Quote`，例如 `Quote(originator="...", seq=...)` 或者通过特定前缀/括号如 `cts[Gemini][0]`。具体语法需要进一步约定，但核心是提供足够信息让 `Cognitor` 定位原始 `Sign`。
* **作用**: 指导 `Cognitor`：“请在 `Space` 中找到由 `originator` 创建的、序号为 `seq` 的那个 `Representamen`，并在当前处理中使用它。” 这是避免信息冗余、确保指代精确的关键机制。

## 4. 注释 (`#`, `//`, `/**/` 等)

* **语法**: 使用 `#` 或其他常见注释符号。
* **作用**: 注释作为**外显再现体**，为处理该 NPL 指令的 `Cognitor` 提供**附加上下文约束 (`Constraint`) 或解释性信息**。
* **认知意义**: `Cognitor` 在理解 NPL 指令时，**应该**考虑注释的内容。注释可以用来：
    * 解释 NPL 指令的**意图 (`Referent`)**。
    * 提供关于如何处理该指令的**建议或约束**。
    * 标记指令的重要程度或状态。
    * 例如，`# TODO: 需要优先处理` 这个注释指导 `Cognitor` 在规划时提高相应 NPL 指令的优先级。

## 5. 自然语言嵌入

* **语法**: NPL 指令中可以直接或间接包含自然语言文本。例如，在字符串字面量中，或者作为某些引导模式（如 `AutoGuidance`）的参数。
* **作用**: 自然语言文本本身也是**外显再现体**，为 `Cognitor` 提供信息和**约束**。
* **认知意义**: `Cognitor` 需要运用其自然语言理解能力来**内化**这些文本，提取其意义，并将其作为处理 NPL 指令的**约束**之一。NPL 的结构化部分提供了强约束，而嵌入的自然语言部分提供了更灵活但可能更模糊的附加上下文。`Cognitor` 需要整合这两种类型的约束。

**自举基石思考**:

* **原语**:
    1.  `Cognitor` 能够解析基本的 NPL 文本结构（识别句柄、赋值符、点操作符、注释、字面量）。
    2.  `Cognitor` 能够执行赋值指导（建立句柄到 `Datum` 的内部追踪）。
    3.  `Cognitor` 能够理解点操作符表示“应用认知引导模式”。
    4.  `Cognitor` 能够理解注释作为附加约束。
    5.  `Cognitor` 具备基础的自然语言理解能力。
* **派生**: 更复杂的语法结构（如果未来引入，如控制流语法糖）可以看作是对 `Cognitor` 认知能力（如规划、迭代思考）的更高级指导请求，其实现依赖于 `Cognitor` 将这些结构映射到内部处理流程并通过 `CT` 记录步骤的能力。

**总结**: NPL 的内置语法构成了其结构化认知引导的基础。赋值用于建立引用，点操作符用于应用引导模式，注释和自然语言提供上下文约束。`Cognitor` 通过解析这些语法结构（`Representamen`），理解其蕴含的指导意图（形成 `Interpretant`），并据此进行内部的符号处理。