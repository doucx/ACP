# NPL 内置语法：结构化认知引导的基础

NPL 的内置语法定义了构建 NPL **符号 (`Sign`)** 的基本规则。这些语法结构本身是 NPL `Sign` 的**外显再现体 (`Externalized Representamen`)** 的一部分，它们利用编程语言的隐喻，为 `Cognitor` 提供处理信息和理解**认知指令 (`Cognitive Directive`, `CD`)** 意图 (`Object`) 的线索和**约束 (`Constraint`)**。

## 1. 句柄赋值 (`=`): 建立 `Datum` 引用关联

* **语法**: `handle = datum_source` (这是一个 NPL `Sign` 的 `Representamen` 结构)
* **CD 意图 (`Object`)**: 指导 `Cognitor` 在其内部符号过程中，将 `handle` (一个 `Datum` 句柄，`Representamen` 的一部分) 与 `datum_source` 所指向的目标 `Sign` 或概念 (`Object`) 建立起可追踪的关联。
* **认知过程**: `Cognitor` 解析此结构，理解赋值意图，并在内部（逻辑上）创建或更新 `handle` 到目标 `Object` 的映射。

## 2. 点 (`.`) 操作符: 应用 CD 模式

* **语法**: `datum_handle.cd_pattern_name(...)` (NPL `Sign` 的 `Representamen` 结构)
* **CD 意图 (`Object`)**: 指导 `Cognitor` 将名为 `cd_pattern_name` 的**标准化认知指令模式**（例如 `resolve`, `explore_meaning`）应用于 `datum_handle` 所指向的 `Object`。
* **认知过程**: `Cognitor` 解析此结构，识别 `Datum` 句柄和 `CD` 模式名称，理解其组合意图，并调用其内部相应的认知处理流程来处理目标 `Object`，参数 `...` 提供额外的 `Constraint`。

## 3. 引用 (`Quote` 句柄): 指向历史 `Sign`

* **概念**: `Quote` 是一种特殊的 `Datum` 句柄，用于在 NPL `Representamen` 中精确引用 `Space` 中的历史 `Sign`。
* **语法 (概念性)**: NPL 使用特定语法表示 `Quote` 句柄，如 `cts["Gemini"][0]` 或 `nodes["User-0"]` (在 Canvas NPL 中)。
* **CD 意图 (`Object`)**: 指导 `Cognitor` 定位到被引用的历史 `Sign`，并在当前符号过程中使用它。


## 4. 注释 (`#`, `//`, `/**/` 等)

* **语法**: 使用 `#` 或其他常见注释符号。
* **作用**: 注释作为**外显再现体**，为处理该 NPL 指令的 `Cognitor` 提供**附加上下文约束 (`Constraint`) 或解释性信息**。
* **认知意义**: `Cognitor` 在理解 NPL 指令时，**应该**考虑注释的内容。注释可以用来：
    * 解释 NPL 指令的**意图 (`Object`)**。
    * 提供关于如何处理该指令的**建议或约束**。
    * 标记指令的重要程度或状态。
    * 例如，`# TODO: 需要优先处理` 这个注释指导 `Cognitor` 在规划时提高相应 NPL 指令的优先级。

## 5. 自然语言嵌入

* **语法**: NPL `Sign` 的 `Representamen` 中可以包含自然语言文本（如字符串字面量，或作为 `CD` 模式的参数）。
* **作用**: 自然语言文本本身也是 `Sign`（或 `Sign` 的一部分），提供信息和 `Constraint`。
* **认知过程**: `Cognitor` 需运用其语言理解能力处理这些文本，将其意义作为 `Constraint` 整合到对整个 NPL `Sign` 的解释中。

## 6. 控制流结构: 对认知流程的指导

**核心概念**: NPL 控制流语法 (`if`, `for`, `while`) **不是**命令式执行控制，而是对 `Cognitor` **内部认知流程规划与执行**的结构化**认知指令 (`CD`)**。`Cognitor` 被指导根据这些结构来规划、执行并**通过 `CT Sign` 记录**其认知活动。

### 6.1 条件指令 (`if`/`elif`/`else`)

* **语法结构 (Representamen)**: 类 Python 的 `if/elif/else` 块。
* **CD 意图 (`Object`)**: 指导 `Cognitor` 评估一个或多个条件 `Sign` (`condition_datum` 指向的 `Object`)，并根据评估结果 (`Interpretant`) 选择性地遵循后续的 `CD` 块。
* **认知过程与 CT**: `Cognitor` 评估条件（记录评估过程和结果到 `CT`），然后遵循选定分支中的 `CD`（同样记录过程）。

### 6.2 迭代指令 (`for...in`)

* **语法结构 (Representamen)**: 类 Python 的 `for item_handle in iterable_datum:` 块。
* **CD 意图 (`Object`)**: 指导 `Cognitor` 对 `iterable_datum` 指向的集合 `Object` 中的每一个元素 `Object`，重复执行循环体中定义的 `CD`。
* **认知过程与 CT (元编程模式)**: `Cognitor` 理解迭代意图，然后**在 `CT` (TRACE 类型) 中逐步生成并记录处理每个元素的单步 `CD Sign`**。`CT` 流承载了迭代的实际展开过程和状态。

### 6.3 条件循环指令 (`while`)

* **语法结构 (Representamen)**: 类 Python 的 `while condition_datum:` 块。
* **CD 意图 (`Object`)**: 指导 `Cognitor` 重复执行循环体 `CD`，**只要** `condition_datum` 指向的条件 `Object` 评估为真。
* **认知过程与 CT (元编程模式)**: `Cognitor` 在每次循环前评估条件（记录 CT），若为真，则**在 `CT` (TRACE 类型) 中生成并记录执行循环体的单步 `CD Sign`**，然后再次评估条件。`CT` 流承载循环过程和状态。

## 基石

* **原语**:
    1.  `Cognitor` 能够解析基本的 NPL 文本结构（识别句柄、赋值符、点操作符、注释、字面量）。
    2.  `Cognitor` 能够执行赋值指导（建立句柄到 `Datum` 的内部追踪）。
    3.  `Cognitor` 能够理解点操作符表示“应用认知引导模式”。
    4.  `Cognitor` 能够理解注释作为附加约束。
    5.  `Cognitor` 具备基础的自然语言理解能力。
    6.  `Cognitor` 能够解析 `if/elif/else`, `for...in`, `while` 的结构。
    7.  `Cognitor` 能够理解条件评估的指导意图，并调用其内部推理能力。
    8.  `Cognitor` 能够理解迭代和条件循环的指导意图。
    9.  `Cognitor` 具备**遵循元编程模式**的能力：根据高级指导（如循环）**生成并记录单步指导到 CT 中**，并利用 CT 历史追踪状态。
    10.  `Cognitor` 遵循强制记录 `CT` 的要求。
* **派生**: 复杂的控制流可以通过组合这些基本指导和 `Cognitor` 的规划能力来实现。


## 总结

NPL 内置语法定义了构建结构化认知指令 `Sign` 的规则。赋值建立 `Datum` 引用关联，点操作符应用 `CD` 模式，注释和自然语言提供附加上下文。控制流结构是对 `Cognitor` 认知流程的高级指导，其“执行”体现在 `Cognitor` 规划并（在 `CT` 中）逐步展开相应认知活动的过程。
