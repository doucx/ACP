# NPL 内置语法：结构化认知引导的基础

NPL 的内置语法是其作为**结构化认知指导语言**的基础。这些语法元素本身也是**外显再现体 (`Externalized Representamen`)**，其结构为 `Cognitor` 提供了处理信息和理解指导意图的线索和**约束 (`Constraint`)**。

## 1. 句柄赋值 (`=`): 创建 Datum 引用

* **语法**: `handle = datum_source`
* **作用**: 这是在 NPL 中创建或更新 **`Datum` 句柄** (`handle`) 的核心方式。它指导 `Cognitor`：
    1.  处理 `datum_source`（可能是一个字面量如 `"text"`，另一个 `Datum` 句柄，或者一个返回 `Datum` 的认知引导模式）。
    2.  将 `handle` 这个名称与其处理结果（一个具体的 `Representamen` 或其引用）在当前的认知上下文中关联起来。之后，`handle` 就可以在后续的 NPL 指导中用来指代这个 `Datum`。
* **认知意义**: 这并非传统编程的内存分配，而是**指导 `Cognitor` 在其内部建立一个符号（`handle`）到另一个符号/概念（`datum_source` 指向的 `Representamen`）的追踪关系**。

## 2. 点 (`.`) 操作符: 应用认知引导模式

* **语法**: `datum_handle.guidance_pattern(...)`
* **作用**: 点操作符用于将一个**认知引导模式**（表现为“方法”名，如 `resolve`, `explore_meaning`）应用到指定的 **`Datum` 句柄** (`datum_handle`) 上。
* **认知意义**: 这**不是**调用对象的方法。它是一个结构化的**指导**，告诉 `Cognitor`：“请对 `datum_handle` 所代表的信息，执行 `guidance_pattern` 所描述的那种认知操作（例如，尝试解析、探索意义、获取文本等）”。具体如何执行该认知操作，取决于 `Cognitor` 对该引导模式的理解和其自身能力。参数 `...` 是为该认知引导提供的额外**约束**或说明。详见 [[15.4_builtin_classes]] 中 `Datum` 的引导模式。

## 3. 引用 (`Quote`): 指向 Space 中的历史 Sign

* **概念**: `Quote` 是一种特殊的 `Datum`，用于精确引用 `Space` 中已存在的某个**外显再现体**。
* **语法 (概念性)**: NPL 可能使用特定语法来创建或表示 `Quote`，例如 `Quote(originator="...", seq=...)` 或者通过特定前缀/括号如 `cts[Gemini][0]`。具体语法需要进一步约定，但核心是提供足够信息让 `Cognitor` 定位原始 `Sign`。
* **作用**: 指导 `Cognitor`：“请在 `Space` 中找到由 `originator` 创建的、序号为 `seq` 的那个 `Representamen`，并在当前处理中使用它。” 这是避免信息冗余、确保指代精确的关键机制。

## 4. 注释 (`#`, `//`, `/**/` 等)

* **语法**: 使用 `#` 或其他常见注释符号。
* **作用**: 注释作为**外显再现体**，为处理该 NPL 指令的 `Cognitor` 提供**附加上下文约束 (`Constraint`) 或解释性信息**。
* **认知意义**: `Cognitor` 在理解 NPL 指令时，**应该**考虑注释的内容。注释可以用来：
    * 解释 NPL 指令的**意图 (`Referent`)**。
    * 提供关于如何处理该指令的**建议或约束**。
    * 标记指令的重要程度或状态。
    * 例如，`# TODO: 需要优先处理` 这个注释指导 `Cognitor` 在规划时提高相应 NPL 指令的优先级。

## 5. 自然语言嵌入

* **语法**: NPL 指令中可以直接或间接包含自然语言文本。例如，在字符串字面量中，或者作为某些引导模式（如 `AutoGuidance`）的参数。
* **作用**: 自然语言文本本身也是**外显再现体**，为 `Cognitor` 提供信息和**约束**。
* **认知意义**: `Cognitor` 需要运用其自然语言理解能力来**内化**这些文本，提取其意义，并将其作为处理 NPL 指令的**约束**之一。NPL 的结构化部分提供了强约束，而嵌入的自然语言部分提供了更灵活但可能更模糊的附加上下文。`Cognitor` 需要整合这两种类型的约束。


## 6. 控制流指导 (Control Flow Guidance)

**重要概念**: NPL 中的控制流语法**不是**命令式编程中的执行控制，而是对 `Cognitor` **内部认知流程的结构化指导**。`Cognitor` 被指导根据条件或迭代需求来**规划并执行其认知活动**（可能是生成进一步的 NPL 指导、调用能力或更新内部状态），并将这个**受指导的规划与执行过程**通过 `Cognitive Trace` (`CT`) 详细记录下来。

### 6.1 条件指导 (`if`/`elif`/`else`)

* **语法 (类 Python)**:
    ```npl
    if condition_datum:
        # 指导 Cognitor 在条件满足时执行的认知活动
        print("Condition was true.")
    elif another_condition_datum:
        # 指导 Cognitor 在另一条件满足时执行的认知活动
        print("Another condition was true.")
    else:
        # 指导 Cognitor 在所有条件都不满足时执行的认知活动
        print("No condition was true.")
    ```
* **作用**: 指导 `Cognitor` 评估一个或多个条件 (`condition_datum`，其本身是一个 `Datum`，可能指向布尔值、需要解析的自然语言判断，或需要 `Cognitor` 自行评估的状态)，并根据评估结果选择性地遵循后续的认知指导。
* **认知过程指导**:
    1.  `Cognitor` 接收到 `if` 指导。
    2.  **内化**并**理解** `condition_datum` 的含义，识别其指向的 `Referent`（需要判断的条件）。
    3.  运用其**推理**和**状态查询能力**评估该 `Referent` 的真值。
    4.  根据评估结果，选择进入对应的指导块 (`if`, `elif`, `else`)。
    5.  **遵循**所选块内的 NPL 指导进行后续认知活动。
* **CT 要求**: **必须**记录：
    * 评估了哪个条件 `Datum`。
    * 评估的过程和依据（如何理解条件 `Referent`，如何判断其真值）。
    * 评估的结果。
    * 最终遵循了哪个分支的指导。

### 6.2 迭代指导 (`for`)

* **语法 (类 Python)**:
    ```npl
    for item_handle in iterable_datum:
        # 指导 Cognitor 对集合中的每个元素执行的认知活动
        print(f"Processing item: {item_handle.get_text()}")
    ```
* **作用**: 指导 `Cognitor` 对 `iterable_datum`（一个指向可迭代概念的 `Datum`，如列表、集合或需要生成序列的描述）中的每一个元素，重复执行指定的认知活动块。
* **认知过程指导 (元编程模式)**:
    1.  `Cognitor` 接收到 `for` 指导。
    2.  **理解**迭代目标 (`iterable_datum`) 和单步操作。
    3.  **规划**迭代过程。`Cognitor` **不应**在内部完成所有迭代。
    4.  **生成并记录第一步**: 创建一个 `CT` 条目 (类型 `TRACE`)，记录当前迭代状态（如索引 0），并包含对第一个元素 (`item_handle` 指向第一个元素) 执行指导块内容的**单步 NPL 指导**。
    5.  **遵循第一步指导**: `Cognitor` (或下一个 `operator`) 处理该 `TRACE` CT 中的单步指导。
    6.  **生成并记录后续步骤**: 在完成上一步后，`Cognitor` (作为 `operator`) 查阅 `Space` 中的 `CT` 历史以确定迭代状态，然后生成并记录包含处理下一个元素（更新 `item_handle` 指向）的**单步 NPL 指导**的 `TRACE` CT。
    7.  重复步骤 5 和 6，直到迭代完成。
    8.  生成并记录迭代结束的 `CT`。
* **CT 要求**: **至关重要**。`CT` 流**承载了迭代过程的实际展开**。每个 `CT` 条目（特别是 `TRACE` 类型）需要包含：
    * 标记（如 `LoopIteration: 1/N`）。
    * 当前迭代元素 `item_handle` 指向哪个 `Datum`。
    * 本步骤要执行的**单步 NPL 指导**。
    * 迭代结束时需有明确标记。

### 6.3 条件循环指导 (`while`)

* **语法 (类 Python)**:
    ```npl
    counter = Datum(0) # 假设 Datum 可以这样初始化
    while counter.less_than(5): # 假设有比较引导模式
        print(f"Counter is {counter.get_text()}")
        counter = counter.add(1) # 假设有算术引导模式
    ```
* **作用**: 指导 `Cognitor` 重复执行指定的认知活动块，**只要**某个条件 (`condition_datum`) 持续满足。
* **认知过程指导 (元编程模式)**:
    1.  `Cognitor` 接收到 `while` 指导。
    2.  **理解**循环条件和循环体操作。
    3.  **规划**循环过程（同样不应内部完成）。
    4.  **评估条件**: 创建 `CT` 记录条件评估过程和结果。
    5.  **若条件满足**:
        * 创建 `CT` (类型 `TRACE`)，记录当前状态，并包含执行循环体内容的**单步 NPL 指导**。
        * `Cognitor` 处理该 `TRACE` CT 中的单步指导。
        * 返回步骤 4，重新评估条件。
    6.  **若条件不满足**: 创建 `CT` 记录循环结束。
* **CT 要求**: `CT` 流承载循环过程。需要记录：
    * 每次条件评估的过程、依据和结果。
    * 每次循环体执行的**单步 NPL 指导**（封装在 `TRACE` CT 中）。
    * 循环结束的标记。

## 自举基石思考

* **原语**:
    1.  `Cognitor` 能够解析基本的 NPL 文本结构（识别句柄、赋值符、点操作符、注释、字面量）。
    2.  `Cognitor` 能够执行赋值指导（建立句柄到 `Datum` 的内部追踪）。
    3.  `Cognitor` 能够理解点操作符表示“应用认知引导模式”。
    4.  `Cognitor` 能够理解注释作为附加约束。
    5.  `Cognitor` 具备基础的自然语言理解能力。
    6.  `Cognitor` 能够解析 `if/elif/else`, `for...in`, `while` 的结构。
    7.  `Cognitor` 能够理解条件评估的指导意图，并调用其内部推理能力。
    8.  `Cognitor` 能够理解迭代和条件循环的指导意图。
    9.  `Cognitor` 具备**遵循元编程模式**的能力：根据高级指导（如循环）**生成并记录单步指导到 CT 中**，并利用 CT 历史追踪状态。
    10.  `Cognitor` 遵循强制记录 `CT` 的要求。
* **派生**: 复杂的控制流可以通过组合这些基本指导和 `Cognitor` 的规划能力来实现。

**总结**: NPL 的内置语法构成了其结构化认知引导的基础。赋值用于建立引用，点操作符用于应用引导模式，注释和自然语言提供上下文约束。控制流语法是对 `Cognitor` 认知流程的结构化指导。条件语句指导基于评估结果的选择性遵循，而循环语句则指导 `Cognitor` 采用元编程模式，在 `Space` 的 `CT` 流中逐步展开迭代或条件重复过程。

`CT` 在此过程中扮演了记录执行踪迹和维持过程状态的关键角色。

`Cognitor` 通过解析这些语法结构（`Representamen`），理解其蕴含的指导意图（形成 `Interpretant`），并据此进行内部的符号处理。