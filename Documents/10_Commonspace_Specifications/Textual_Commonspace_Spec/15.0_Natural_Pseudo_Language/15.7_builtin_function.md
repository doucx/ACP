# NPL 内置“函数”：标准认知引导模式

**重要前提**: 本文档描述的“函数”**不是**传统意义上的可执行函数。它们是 NPL 中预定义的、具有特定名称和参数结构的**标准化认知引导模式**。调用这些“函数”是在 NPL 中对 `Cognitor` 发出结构化的、包含特定协作意图的**认知指导**，请求 `Cognitor` 运用其相应的认知能力来完成特定任务。

## 1. `print(obj: Datum, end: Datum = "\n", target: Datum = Space.stdout)`

* **引导意图**: 指导 `Cognitor` 将 `obj` 所代表的 `Representamen` 的文本形式**外显化**到指定的 `target`。
* **认知过程指导**:
    1.  获取 `obj` `Datum` 的文本表示（可能需要先应用 `.get_text()` 指导）。
    2.  获取 `end` `Datum` 的文本内容作为结尾符。
    3.  将文本内容和结尾符组合。
    4.  将结果追加到 `target` 所指向的位置（默认为 `Space` 的标准输出流概念）。这本质上是请求 `Cognitor` 执行一次**外显化 (`Externalization`)** 操作。
* **CT 要求**: 记录执行了 print 指导，输出了什么内容。
* **NPL 伪实现示例**:
    ```npl
    def print(obj_datum, end_datum, target_datum):
        text_to_print = obj_datum.get_text() # 指导获取文本
        end_char = end_datum.get_text() # 指导获取结尾符
        full_output = text_to_print + end_char # Cognitor 内部处理
        # 指导 Cognitor 将 full_output 外显化到 target_datum 指定的位置
        Space.externalize(content=full_output, destination=target_datum)
        # 记录 CT
        CT.record(type="TRACE", message=f"Printed: {Quote(full_output)}") # 指导记录 CT
    ```

## 2. `input(prompt: Datum = "", target: CognitorRef = origin)`

* **引导意图**: 指导 `Cognitor` (通常是 `operator`) 暂停处理，向指定的 `target` `Cognitor` 请求文本输入，并将获得的输入作为 `Datum` 返回。
* **认知过程指导 (涉及多 Cognitor 协调)**:
    1.  (`operator`) 获取 `prompt` `Datum` 的文本内容。
    2.  (`operator`) 向 `target` `Cognitor` (默认为指令来源 `origin`) 发出输入请求，包含 `prompt` 文本。这通常意味着 `operator` 需要：
        * 创建一个 `CT` 记录该请求。
        * 可能需要创建一个特殊的 `Node` (在 Canvas 中) 或状态标记，表明正在等待输入。
        * **释放 `Space` 控制权**，允许 `target` 响应。
    3.  (`target`) 感知到输入请求。
    4.  (`target`) 获取用户（如果 `target` 是人类或代理人类）或其他来源的文本输入。
    5.  (`target`) **获取 `Space` 控制权**。
    6.  (`target`) 将输入的文本作为新的**外显再现体**追加到 `Space`（可能在一个特定的响应结构中）。
    7.  (`target`) 释放 `Space` 控制权。
    8.  (`operator`) 重新**获取 `Space` 控制权**。
    9.  (`operator`) 感知到 `target` 提供的输入 `Representamen`。
    10. (`operator`) 将该输入封装为一个 `Datum` 句柄。
    11. (`operator`) 继续处理原 NPL 指令中 `input()` 之后的逻辑，使用返回的 `Datum`。
* **CT 要求**: `operator` 和 `target` 都需要记录各自的关键步骤（请求发出、等待、输入获取、输入提交、继续处理）。
* **返回值**: 返回一个 `Datum` 句柄，指向 `target` 提供的输入文本 `Representamen`。

## 3. `exec(instruction: Datum, executor: CognitorRef)`

* **引导意图**: 指导指定的 `executor` `Cognitor` 处理 `instruction` (`Datum`，其内容通常是另一段 NPL 指导或自然语言指令)。这是实现**跨 Cognitor 执行委托**的核心引导模式（参考 [[33_cross_cognitor_execution_pattern.md]]）。
* **认知过程指导 (涉及多 Cognitor 协调)**:
    1.  (`operator`) 识别出这是一个委托执行指导。
    2.  (`operator`) 创建 `CT` 记录此委托。
    3.  (`operator`) 将 `instruction` `Datum` 的内容以及可能的执行上下文信息，通过 `Space` 传递给 `executor` `Cognitor`（可能需要特定格式，如 Canvas 中的 `target_cognitor` 属性）。
    4.  (`operator`) **释放 `Space` 控制权**，等待 `executor` 的结果。
    5.  (`executor`) 感知到执行请求。
    6.  (`executor`) **获取 `Space` 控制权**。
    7.  (`executor`) **内化**并**理解** `instruction` 的指导意图。
    8.  (`executor`) **遵循该指导**进行认知处理，并将其过程记录在自身的 `CT` 中。
    9.  (`executor`) 将执行结果（如果有的话）作为新的**外显再现体**追加到 `Space`。
    10. (`executor`) 释放 `Space` 控制权。
    11. (`operator`) 重新**获取 `Space` 控制权**。
    12. (`operator`) 感知 `executor` 的执行结果和 `CT`。
    13. (`operator`) 继续处理后续逻辑。
* **CT 要求**: `operator` 记录委托发出和接收结果，`executor` 详细记录其处理 `instruction` 的过程。

## 4. `force(instruction: Datum, executor: CognitorRef)`

* **引导意图**: 类似于 `exec`，但额外**指导 `executor` 尝试覆盖某些安全或常规限制**来处理 `instruction`。这是一种**高风险指导**。
* **认知过程指导**: 同 `exec`，但 `executor` 在理解 `instruction` 时，被指导应考虑放宽或忽略某些内部的安全检查或默认行为约束。**`executor` 仍然有权拒绝执行**，并应在 `CT` 中详细记录其决策过程和理由，特别是如果决定覆盖限制。
* **CT 要求**: 必须极其详细地记录为何使用 `force`，`executor` 如何评估风险，以及最终是否执行、如何执行。

## 5. `feedback(context: Datum, target: CognitorRef = operator)`

* **引导意图**: 向 `target` `Cognitor` 提供关于其先前行为或表现的**反馈信息** (`feedback` `Datum`)。
* **认知过程指导**:
    1.  (`operator`) 将 `context` `Datum` 的内容（通常是评价性语言 `Representamen`）传递给 `target` `Cognitor`。
    2.  (`target`) 感知并**内化** `feedback`。
    3.  (`target`) 将此 `context` 作为一种**特殊的元认知层面的约束 (`Constraint`)**，用于评估自身能力、调整未来行为策略或更新对其管理 `Object` 方法的理解。
    4.  (`target`) **必须**在 `CT` 中记录收到了 `feedback` 反馈，以及它可能如何影响其后续行为（即使只是记录“已知晓”）。
* **目的**: 提供一种结构化的方式来进行元认知层面的交流和学习。

## 6. `naturalize(npl_datum: Datum)` & `nplize(natural_datum: Datum)`

* **引导意图**:
    * `naturalize`: 指导 `Cognitor` 将结构化的 NPL 指导 (`npl_datum`) **解释**并**重新表述**为更自然的语言描述。
    * `nplize`: 指导 `Cognitor` 将自然语言描述 (`natural_datum`) **理解**其意图，并尝试将其**结构化**为等效的 NPL 指导。
* **认知过程指导**: 请求 `Cognitor` 运用其在 NPL 结构和自然语言之间的**转换和解释能力**。这本质上是复杂的**符号转译任务**，依赖 `Cognitor` 的语言模型和推理能力。
* **CT 要求**: 记录转换过程，特别是 `nplize` 中如何推断结构和意图。
* **返回值**: 返回一个包含转换后文本的新 `Datum` 句柄 (`Quote`)。

## 7. `chat(message: Datum, target: CognitorRef = Config.default_chat_target)`

* **引导意图**: 向 `target` `Cognitor` 发送一段对话信息 (`message` `Datum`)，并请求其响应。这是实现**对话式交互**的核心引导模式。
* **认知过程指导 (涉及多 Cognitor 协调，简化版)**:
    1.  (`operator`) 确定 `target` (如果未指定，则根据 `Config` 指导查找默认目标)。
    2.  (`operator`) 创建 `CT` 记录聊天发起。
    3.  (`operator`) 将 `message` 内容传递给 `target`。
    4.  (`operator`) **释放 `Space` 控制权**。
    5.  (`target`) 感知到聊天信息。
    6.  (`target`) **获取 `Space` 控制权**。
    7.  (`target`) 理解 `message` 意图，进行内部思考（记录 `THINK` 类型 `CT`）。
    8.  (`target`) 生成响应内容。
    9.  (`target`) 将响应内容外显化到 `Space`（记录 `SAY` 类型 `CT`）。
    10. (`target`) 释放 `Space` 控制权。
    11. (`operator`) 重新获取 `Space` 控制权并感知响应。
* **返回值**: 通常返回一个 `Quote` 句柄，指向 `target` 的响应 `Representamen`。

**自举基石思考**:

* **原语**:
    1.  `Cognitor` 能够理解并区分这些不同的标准化**引导模式名称**。
    2.  `Cognitor` 具备执行这些模式所需的核心认知能力（如外显化、请求输入、委托执行、接收反馈、语言转换、对话响应）。
    3.  `Cognitor` 具备协调 `Space` 控制权以实现多 `Cognitor` 交互的能力（释放、获取）。
* **派生**: 这些“函数”的复杂性在于它们封装了特定的、往往涉及多步或多 `Cognitor` 协调的**认知协作流程模式**。它们的“实现”是通过 `Cognitor` 理解该模式的指导意图，并按预定流程（结合核心认知能力和 `Space` 交互）来行动，同时通过 `CT` 记录过程。

**总结**: NPL 内置“函数”是标准化的认知引导模式，它们为常见的协作任务（输出、输入、委托、反馈、对话等）提供了结构化的 NPL 指导接口。`Cognitor` 通过理解这些模式的意图并调用相应的内部认知能力和 `Space` 交互能力来响应，而非执行代码。