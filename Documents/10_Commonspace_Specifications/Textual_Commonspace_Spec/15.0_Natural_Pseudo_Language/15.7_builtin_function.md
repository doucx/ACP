# NPL 内置“函数”：标准化认知指令模式 (`CD` Patterns)

**重要前提**: 本文档描述的 NPL 内置“函数”**不是**传统意义上的可执行函数调用。它们是 NPL 中预定义的、具有特定名称和参数结构的**标准化认知指令模式 (`Standardized CD Patterns`)**。这些模式体现在特定的 NPL 符号 (`Sign`) 结构中。当 `Cognitor` 处理这些 NPL `Sign` 时，它被**指导**运用其相应的认知能力来完成特定的、常见的协作任务。

## 1. `print(obj: Datum, end: Datum = "\n", target: Datum = ...)` (`CD` Pattern)

* **NPL `Sign` 结构**: `print(obj, end?, target?)`
* **CD 意图 (`Object`)**: 指导 `Cognitor` 将 `obj` `Datum` 指向的 `Sign` 的 `Representamen` 文本形式，**外显化 (`Externalization`)** 到 `target` 指定的位置（通常是 `Space` 的某个输出区域概念，如 Canvas 中的 `<stdout>`)。
* **认知过程指导**:
    1.  `Cognitor` 解析 `print` `Sign`，识别 `Object` (要输出的 `Sign`) 和 `Constraint`s (结尾符 `end`，目标 `target`)。
    2.  获取 `obj` `Sign` 的文本 `Representamen`。
    3.  组合文本与结尾符。
    4.  执行外显化动作，将结果追加到 `target`。
* **CT 要求**: 记录执行了 `print` 指导，输出了什么内容 (`Sign` 的引用或文本)，以及输出目标。

## 2. `input(prompt: Datum = "", target: CognitorRef = origin)` (`CD` Pattern)

* **NPL `Sign` 结构**: `input(prompt?, target?)`
* **CD 意图 (`Object`)**: 指导 `Cognitor` (通常是 `operator`) 向 `target` `Cognitor` 请求文本输入，并将获得的输入 `Sign` 作为结果供后续处理。
* **认知过程指导 (多 `Cognitor` 协调)**:
    1.  (`operator`) 解析 `input` `Sign`，理解请求输入的意图。
    2.  向 `target` 发出请求（可能通过创建如 `InteractionRequestNode` 的特定 `Sign`），包含 `prompt` 内容。记录 `CT`。
    3.  `operator` **释放 `Space` 控制权**。
    4.  (`target`) 接收请求，获取输入。
    5.  `target` **获取控制权**，将输入作为新 `Sign`（如 `InteractionResponseNode`）添加到 `Space`。记录 `CT`。
    6.  `target` **释放控制权**。
    7.  (`operator`) **重新获取控制权**，感知响应 `Sign`。
    8.  将响应 `Sign` 与 NPL 中 `input()` 调用的位置关联起来（逻辑上）。
* **CT 要求**: `operator` 和 `target` 都需记录各自的关键步骤。
* **返回值 (概念性)**: 在 NPL 逻辑流中，`input()` 指令完成后，其位置（逻辑上）关联到 `target` 提供的输入 `Sign` 的 `Datum` 句柄。

## 3. `exec(instruction_sign: Datum, executor: CognitorRef)` (`CD` Pattern)

* **NPL `Sign` 结构**: `exec(instruction_sign, executor)`
* **CD 意图 (`Object`)**: 指导 `operator` 将 `instruction_sign` (`Datum` 指向一个 `CD Sign`，可以是 NPL 或自然语言) **委托**给指定的 `executor` `Cognitor` 进行处理。实现跨 `Cognitor` 任务分配。
* **认知过程指导 (多 `Cognitor` 协调)**:
    1.  (`operator`) 解析 `exec` `Sign`，理解委托意图。记录 `CT`。
    2.  将 `instruction_sign` 及其上下文传递给 `executor` (通过 `Space`)。
    3.  `operator` **释放控制权**，等待结果。
    4.  (`executor`) 接收请求，**获取控制权**。
    5.  `executor` **处理 `instruction_sign`** (执行其内部符号过程)，并将其过程记录在自身的 `CT` 中。
    6.  `executor` 将结果（如有）作为新 `Sign` 添加到 `Space`。
    7.  `executor` **释放控制权**。
    8.  (`operator`) **重新获取控制权**，感知结果和 `executor` 的 `CT`。
* **CT 要求**: `operator` 记录委托发出/接收结果，`executor` 详细记录其处理 `instruction_sign` 的过程。

## 4. `force(instruction_sign: Datum, executor: CognitorRef)` (`CD` Pattern)

* **NPL `Sign` 结构**: `force(instruction_sign, executor)`
* **CD 意图 (`Object`)**: 类似于 `exec`，但额外**指导 `executor` 在处理 `instruction_sign` 时，尝试覆盖某些内部的安全或常规限制 `Constraint`**。这是**高风险指令**。
* **认知过程指导**: 同 `exec`，但 `executor` 被指导应考虑放宽约束。**`executor` 仍有权拒绝执行**，并应在 `CT` 中详细记录风险评估和决策过程，尤其是决定覆盖限制时。
* **CT 要求**: 极其详细地记录使用 `force` 的理由、风险评估、执行决策。

## 5. `feedback(feedback_sign: Datum, target: CognitorRef = operator)` (`CD` Pattern)

* **NPL `Sign` 结构**: `feedback(feedback_sign, target?)`
* **CD 意图 (`Object`)**: 向 `target` `Cognitor` 提供关于其先前行为或表现的**反馈信息 `Sign`** (`feedback_sign`)。
* **认知过程指导**:
    1.  (`operator`) 将 `feedback_sign` 传递给 `target`。
    2.  (`target`) 感知并内化 `feedback_sign`。
    3.  `target` 将此 `feedback_sign` 作为**元认知层面的 `Constraint`**，用于评估自身、调整策略。
    4.  `target` **必须**在 `CT` 中记录收到了反馈及其可能的影响。
* **目的**: 结构化的元认知交流与学习机制。

## 6. `naturalize(npl_sign: Datum)` & `nplize(natural_sign: Datum)` (`CD` Patterns)

* **NPL `Sign` 结构**: `naturalize(npl_sign)` / `nplize(natural_sign)`
* **CD 意图 (`Object`)**:
    * `naturalize`: 指导 `Cognitor` 将结构化的 NPL `Sign` **重新表述**为自然语言 `Sign`。
    * `nplize`: 指导 `Cognitor` 理解自然语言 `Sign` 的意图，并尝试将其**结构化**为等效的 NPL `Sign`。
* **认知过程指导**: 请求 `Cognitor` 运用其在 NPL 结构（编程隐喻）和自然语言之间的**符号转译和解释能力**。
* **CT 要求**: 记录转换过程，特别是 `nplize` 中如何推断 NPL 结构。
* **返回值 (概念性)**: 返回包含转换后文本 `Representamen` 的新 `Sign` 的 `Datum` 句柄。

## 7. `chat(message_sign: Datum, target: CognitorRef = Config.default_chat_target)` (`CD` Pattern)

* **NPL `Sign` 结构**: `chat(message_sign, target?)`
* **CD 意图 (`Object`)**: 向 `target` `Cognitor` 发送对话信息 `Sign` (`message_sign`)，并请求其响应。实现对话式交互。
* **认知过程指导 (多 `Cognitor` 协调, 简化版)**:
    1.  (`operator`) 解析 `chat` `Sign`，确定 `target`。记录 `CT`。
    2.  将 `message_sign` 传递给 `target`。
    3.  `operator` **释放控制权**。
    4.  (`target`) 接收信息，**获取控制权**。
    5.  `target` 理解 `message_sign` 意图，进行内部思考（记录 `THINK CT`）。
    6.  生成响应 `Sign`。
    7.  将响应 `Sign` 外显化到 `Space`（记录 `SAY CT`）。
    8.  `target` **释放控制权**。
    9.  (`operator`) 重新获取控制权并感知响应。
* **返回值 (概念性)**: 逻辑上关联到 `target` 响应 `Sign` 的 `Datum` 句柄。

## 总结

NPL 内置“函数”是标准化的认知指令模式 (`CD Patterns`)，封装了常见的协作任务流程。它们通过特定的 NPL 符号 (`Sign`) 结构被识别。`Cognitor` 通过理解这些 `Sign` 的指导意图 (`Object`) 并调用相应的内部认知能力和 `Space` 交互能力（如控制权交换）来响应，而非执行代码。所有过程都需通过 `CT` 记录。