# NPL 模板系统 (Template System)

## 1. 简介与目标

NPL 模板系统提供了一种在 NPL 中定义和使用文本模板的机制，旨在**指导 `Cognitor` 生成结构化、格式一致的输出内容**。它并非一个独立的渲染引擎，而是作为一套**认知引导模式**，利用 `Cognitor` 的理解和生成能力，依据模板结构和上下文数据来产生最终的文本 `Representamen`。

**核心目标**:

1.  **结构化输出指导**: 为生成具有特定结构（如 XML、JSON、Markdown、或其他自定义格式）的文本提供清晰的指导。
2.  **内容填充**: 指导 `Cognitor` 将上下文数据 (`Datum`) 填充到模板的指定位置。
3.  **一致性**: 确保重复性任务能生成格式一致的输出。
4.  **Canvas 基石**: 作为使用 NPL 实现 Canvas ([[21.3.1_npl_reference_library]]) 的基础，用于指导生成 Canvas 的 XML 节点结构。
5.  **SpaceLog 集成**: 可用于为 `SpaceLog` 生成结构化的日志消息 `Datum`。

## 2. 模板语法 (建议)

模板本身是一个**文本 `Datum`**。为了简单和通用性，可以借鉴常见模板引擎的语法，例如：

* **变量/占位符**: 使用双大括号 `{{ variable_handle }}`。`variable_handle` 是一个 `Datum` 句柄。
    * 示例: `Hello, {{ user.name }}!`
* **注释**: 使用 `{# comment #}`。
* **控制结构 (可选，作为高级指导)**:
    * **条件**: `{% if condition_datum %} ... {% else %} ... {% endif %}`
    * **循环**: `{% for item_handle in list_datum %} ... {% endfor %}`
    * **注意**: 模板内的控制结构**不是** NPL 控制流。它们是**模板渲染过程中的指导**，告诉 `Cognitor` 在生成文本时如何根据条件或列表数据进行选择或重复。

**示例模板 (`Datum` 内容)**:

```xml
{# Canvas Node 模板示例 #}
<Node origin="{{ node_origin }}" seq="{{ node_seq }}" type="{{ node_type }}">
  {% if depends_on_list %}
  <depends_on>
    {% for link_target in depends_on_list %}
    <link target="{{ link_target }}" />
    {% endfor %}
  </depends_on>
  {% endif %}
  <value>{# 这里假定 value 是简单文本 #}{{ node_value }}</value>
  {# 可能还有 CT 等其他部分 #}
</Node>
````

## 3. 核心认知引导模式

模板系统通过以下 NPL 引导模式进行交互：

  * **`Template(template_datum: Datum)` (构造引导)**

      * **引导意图**: 指导 `Cognitor` 将 `template_datum`（其内容是模板字符串）识别为一个模板对象句柄。
      * **返回值**: 返回一个代表该模板的 `Datum` 句柄（例如 `my_template`）。

  * **`template_handle.render(context: Datum) -> Datum` (渲染引导)**

      * **引导意图**: 指导 `Cognitor` 使用 `context` `Datum`（通常是一个包含键值对的对象或映射概念的 `Datum`）中提供的数据，来填充 `template_handle` 所代表的模板，并生成最终的文本输出。
      * **认知过程指导**:
        1.  `Cognitor` 理解渲染请求，识别模板 (`template_handle`) 和上下文数据 (`context`)。
        2.  解析模板结构，识别其中的变量占位符和控制结构。
        3.  对于每个占位符 `{{ key }}`，从 `context` `Datum` 中查找 `key` 对应的值 (`Datum`)，并获取其文本表示。
        4.  对于模板内的控制结构（`if`/`for`），根据 `context` 数据评估条件或进行迭代，选择性地或重复地处理模板片段。
        5.  将所有处理过的片段和填充的文本组合起来，形成最终的输出字符串。
        6.  将输出字符串封装为一个新的 `Datum` 句柄并返回。
      * **CT 要求**: 需要记录模板渲染的关键步骤，例如查找了哪些上下文变量，如何处理了控制结构，以及最终生成的文本。
      * **返回值**: 返回一个 `Datum` 句柄，其内容是渲染后的文本字符串。

## 4. 使用场景示例

### 4.1 生成 Canvas Node XML

```npl
# 假设 node_template_str 是包含上面示例 XML 模板的 Datum
# 假设 node_data 是一个包含 node_origin, node_seq 等键值对的 Datum

canvas_node_template = Template(node_template_str)
rendered_xml_datum = canvas_node_template.render(context=node_data)

# rendered_xml_datum 现在包含了一个填充好数据的 XML 字符串 Datum
# 可以进一步指导 Cognitor 将此 Datum 内容追加到 Canvas Space 中
Space.append(rendered_xml_datum) # 假设有追加操作指导
```

### 4.2 生成结构化 SpaceLog 消息

```npl
log_template_str = Datum("Event: {{ event_name }}, Status: {{ status_code }}, Details: {{ details }}")
let event_data 包含 event_name, status_code, details

log_message_template = Template(log_template_str)
structured_log_datum = log_message_template.render(context=event_data)

# 使用渲染后的结构化 Datum 进行日志记录
SpaceLog.info(message=structured_log_datum)
```

## 5. 设计原则与认知依赖

  * **认知引导**: 模板系统完全依赖 `Cognitor` 的理解和生成能力。模板是指导，渲染是 `Cognitor` 遵循指导的认知任务。
  * **简单性**: 语法设计力求简单直观，易于 `Cognitor` 理解和处理。
  * **灵活性**: 可以定义任意文本结构的模板。
  * **无状态**: 模板本身无状态，渲染结果仅依赖于模板内容和提供的上下文 `Datum`。
  * **可追溯性**: 渲染过程通过 `CT` 记录，确保透明度和可调试性。