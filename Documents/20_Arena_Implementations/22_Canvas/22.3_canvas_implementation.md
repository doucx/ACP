# ACP Canvas 实现规范
## 基本介绍
1. **概述**  
本文档定义 `ACP Canvas` —— 一种基于 **ACP Textual Arena** 的标准化实现框架，其核心特征如下：  
- 采用 **XML 风格** 的声明式语法（支持自动语法迁移）  
- 以 **Node** 为基本交互单元  
- 通过 `<Canvas>` 作为根节点构建逻辑拓扑  

## Arena
*  在 Canvas  中，`Cognitor` 主要通过 **创建文本并管理 `Node` 流**来管理 `Arena`。其具体运作方式由 `Cognitor` 对协议规则的理解和模拟驱动，包含以下关键方面：

    1.  **上下文维护:** 通过解析输入 (`CDExec`, `FormaInput` Node) 和创建输出 (`ProcessOutput` Node，包含 `stdout`, 认知轨迹, `value` 等)，完全基于可见的文本历史（`Node` 序列）来维护交互上下文。
    2.  **基于规则的 `Node` 创建 (状态机行为):** `Cognitor` **主动监听并响应**特定事件或 `Node` 状态，以按规则自动创建新的 `Node`，驱动交互流程。这种“状态转换”机制主要包括：
        *   **`CDExec` -> `ProcessOutput`:** 在处理完一个 `type="CDExec"` 的 `Node` (且未指定 `target_cognitor`)后，自动创建一个对应的 `type="ProcessOutput"` 的 `Node` 来展示执行结果和认知轨迹。
        *   **`FormaInput` -> `ProcessOutput`:** 在用户提交一个 `type="FormaInput"` 的 `Node`（响应 `input()` 调用）后，自动创建一个新的 `type="ProcessOutput"` `Node` 来继续执行原 `CDExec` `Node` 中 `input()` 之后的语句。
        *   **`input()` 调用 -> 等待 `FormaInput`:** 当在 `CDExec` `Node` 中遇到 `input()` 调用时，`Cognitor` 会暂停当前 `ProcessOutput` `Node` 的创建，并将其标记为等待状态（例如，设置 `<value type="FormaInput_HINT">` 和 `<flags><flag value="WAIT"/></flags>`)，**等待**目标 `Cognitor` 创建并提交相应的 `type="FormaInput"` `Node`。
        *   **委托执行 (Delegated Execution) -> 等待响应**: 当处理带有 `target_cognitor` 的 `CDExec` Node 时，Cognitor 将请求路由给目标，并等待目标 Cognitor 返回结果 Node (通常是 `ProcessOutput` 类型)。Cognitor 需要维护等待状态，并在收到响应后恢复流程 (例如，将结果传递给原始请求者)。
        *   **`Flag` 驱动创建:** 明确的 `Node` 标记（如 `<flags><flag value="ThenCreateNode"/></flags>`）可以指示 `Cognitor` 在处理完当前 `Node` 后需要立即创建并处理一个（通常由 Fhrsk 或系统预定义的）新 `Node`，而不只是等待用户输入。
    3.  **路由决策 (Routing):** `Cognitor` (通过 `Cognitor` 的模拟) 需要根据 `CDExec` Node 的内容（如 `chat` 关键字）或属性 (`target_cognitor`) 决定请求是内部处理、路由给 Fhrsk，还是委托给其他 Cognitor。这些决策**必须**记录在 `<ct>` 中。
    4.  **纯文本基础:** 其“纯文本”特性在 Textual Cognitor 中表现为结构化（如 XML 风格）的文本记录，整个交互流程和状态变迁都必须通过这些文本记录来体现。

## Canvas 节点

**目标 (Goal):**
`<Canvas>` 是整个 ACP Canvas 交互的**根容器**。它代表了交互发生的完整“画布”或“空间”，包含了 `Arena` 中所有的交互单元 (`<Node>`) 以及 对 Arena 的元操作记录 (`<ct type="INFO">`)。它的存在确保了所有交互历史和上下文都被组织在一个统一的结构下。在 Canvas 协议中，它相当于 ArenaContext 本身。

**核心结构 (Structure):**

`<Canvas>` 节点 **必须** 包含以下两种类型的子元素：

1.  `<Node>` (交互单元, **允许多个**):
    *   **说明:** 这是构成交互主体的主要元素。每个 `<Node>` 代表一次输入、输出或信息交换，按照交互发生的顺序依次排列。详细定义请参考 `<Node>` 节点的说明。
    *   **排序:** `Node` 节点通常按照它们被创建和添加到 Canvas 的时间顺序排列，但它们之间的逻辑依赖关系由 `<depends_on>` 元素定义。

2.  `<ct>` (Arena 操作认知轨迹, **必需, 至少一个，允许多个**):
    *   **说明:** 在 `<Canvas>` 下的认知轨迹**专门用于记录  Cognitor 在协调 Arena 内容时自身的行为和决策过程**，这些认知轨迹与任何特定 `Node` 内部的执行细节是分开的。它提供了对 Arena 如何管理交互流程、处理不确定性以及维护环境状态的透明度。
    *   **位置:** Arena 操作认知轨迹可以出现在 `<Canvas>` 内的任何位置，通常建议放在相关 `<Node>` 之后，以记录 Arena 对该 `Node` 的处理元信息，或者放在 `<Canvas>` 的末尾汇总记录。使用多个 Arena 认知轨迹可以方便将认知轨迹与特定的交互阶段关联起来。

## Node 节点
### 基本单元
**目标 (Goal):**
`Node` 是 Canvas 中的基本交互单元。它封装了一段用户的输入、系统的输出、或者特定类型的信息，并记录了其来源 (`originator`) 和在交互序列中的位置 (`seq`)。每个 Node 构成了一个交互的有向无环图 (DAG) 中的一个节点。

### 核心属性 (Attributes)
*   `originator` (文本, **必需**):
    *   **说明:** 这个属性 **必须** 明确指出是哪个 Cognitor (例如 "User", "Gemini", "Fhrsk") 创建了这个 `Node`。这对追踪交互流程至关重要。
    *   **示例:** `originator="User"`
*   `seq` (整数, **必需**):
    *   **说明:** 这个属性 **必须** 是一个从 0 开始递增的整数，标识这是 *当前这个 `originator`* 创建的第几个 `Node`。不同 `originator` 的 `seq` 计数是独立的。
    *   **示例:** `seq="0"`, `seq="1"`
*   `type` (文本, **必需**):
    *   **说明:** 这个属性 **必须** 指明 `Node` 的类型... 常见类型包括：
        *   `CDExec`: 包含用户或 Cognitor 希望执行的认知指令或代码。`Arena` 看到它后，通常会紧接着创建一个 `ProcessOutput` Node 来展示结果，**除非指定了 `target_cognitor`**。
        *   `ProcessOutput`: 包含执行 `CDExec` 或 `FormaInput` 后的结果，包括标准输出 (`<stdout>`)、认知轨迹 (`<ct>`) 和最终值 (`<value>`)。
        *   `FormaInput`: 用户响应 `input()` 调用而提供的输入内容。`Arena` 获得此 Node 后会继续执行之前的逻辑。
        *   *(其他类型可以根据需要定义)*
    *   **示例:** `type="CDExec"`
*   `target_cognitor` (文本, **可选**):
    *   **说明:** **(新增)** 指定期望执行此 Node 内容的目标 Cognitor 的标识符 (例如, `"User"`, `"DataAnalysisAI"`)。如果指定，任务将路由给目标 Cognitor。详见 `33_cross_cognitor_execution_pattern.md`。
    *   **示例:** `target_cognitor="User"`
*   `execution_context` (文本, **可选**):
    *   **说明:** **(新增)** 当 `target_cognitor` 被指定时，此属性描述目标 Cognitor 应在何种上下文或环境执行指令 (例如, `"local_fish_shell"`, `"python_sandbox"`, `"knowledge_base_query"`). Arena 将此信息传递给目标 Cognitor。默认为 Arena 的标准执行上下文。
    *   **示例:** `execution_context="local_fish_shell"`

### 包含的节点 (Child Elements)

#### `<depends_on>` (节点, **可选**):

*   **说明:**  这个元素 **可以** 包含一个或多个 `<node>` 引用，指向当前 `Node` 所依赖的前置 `Node`，形成 `Node` 之间的逻辑关系图 (DAG)。如果省略，`Arena` (Cognitor) 可能需要根据上下文推断依赖关系。
*   **结构:** 内部包含 `<node originator="..." seq="..."/>` 元素。
*   **示例:** 
```xml
<depends_on>
	<node originator="User" seq="0"/>
</depends_on>
```

#### `<value>` (节点, **必需**):

*   **说明:** 通常包含 `Node` 的核心内容。对于 `CDExec` 和 `FormaInput` 类型的 Node，这 **必须** 包含用户输入的文本。对于 `ProcessOutput` 类型的 Node，它可以包含执行的最终结果值，或者在等待输入时包含提示信息 (`type="FormaInput_HINT"` 属性)。
*   **属性 (可选):** `<value>` 自身可以有 `type` 属性 (如 `FormaInput_HINT`) 来提供额外信息。
*   **示例:** 
```xml
<value>
print("Hello")
</value>
```

```xml
<value type="FormaInput_HINT">
请输入你的名字:
</value>
```

#### `<ct>` (节点, **可选, 允许多个**):

*   **说明:** 包含详细的认知轨迹条目，用于记录 Cognitor 的思考过程、执行步骤或遇到的问题。遵循单独的认知轨迹协议规范。每个 `<ct>` 都有自己的内部 `seq`。
*   **结构:** 遵循 `<ct>` 节点的定义（包含 `originator`, `type`, `seq`, `message`, `entry_type` 等）。
*   **示例:** 

```xml
<ct originator="Fhrsk" type="INFO" seq="42">
  <message>
	总之，我意识到需要获取用户位置信息，我需要询问用户所在城市。
	接下来，我将创建一个 CDExec Node ，并直接询问用户所在城市来获取用户城市信息。
  </message>
  <entry_type value="ReasoningNarrative"/>
</ct>
```

#### `<stdout>` (节点, **可选, 允许多个**):

*   **说明:** 包含NPL执行过程中产生的标准输出信息 (例如 `print()` 函数的输出)。每个 `<stdout>` 都有自己的内部 `seq`。
*   **示例:** 
```xml
<stdout seq="0">
	Hello World
</stdout>
```

#### `<flag>` (节点, **可选**):
*   **说明:** 特殊的标记，用于指导 `Cognitor` 操作 `Arena` 时的行为。
*   **结构:** `<flag value="..."/>` 。
* flag 推荐值包括：
	* `WAIT_{Cognitor Name}`: 表示等待 Cognitor Name 的 FormaInput Node 。
	* `ThenCreateNode`: 在该Node结束后立即创建新 Node。

*   **示例:** 
```xml
<flag value="WAIT_Gemini"/>
<flag value="ThenCreateNode"/>
```

**Cognitor 处理要点 (Cognitor Handling Notes):**
*   当你操作 `Arena` 来处理一个新的 `CDExec` Node 时:
    *   **检查 `target_cognitor`**: 如果指定了 `target_cognitor`，你需要将此 Node 的执行请求（包括 `<value>` 和 `execution_context`）路由给目标 Cognitor，并进入等待状态，期望接收到一个或多个包含结果的响应 Node (通常是 `ProcessOutput` 类型)。具体路由和等待机制取决于 Arena 实现。
    *   **标准执行**: 如果未指定 `target_cognitor`，你需要读取 `<value>` 中的指令，模拟执行它们，并将标准输出记录到 `<stdout>`，详细的执行过程和思考记录到 `<ct>`，最终结果（如果有）放入对应 `ProcessOutput` Node 的 `<value>`。
*   当你遇到 `input()` 调用时，你需要创建一个带有 `<value type="FormaInput_HINT">` 和 `<flag value="WAIT_{Cognitor Name}"/>` 的 `ProcessOutput` Node，然后暂停，等待用户提供 `FormaInput` Node。
*   你需要根据 `<depends_on>` 或上下文理解 `Node` 之间的关系。
*   你需要独立维护每个 `originator` 的 `Node` `seq` 计数，以及每个 `Node` 内部 `ct` 和 `stdout` 的 `seq` 计数。


### CDExec 执行单元
```xml
 <Node 
	type="CDExec"
	><!-- 其它属性相同 -->
	<value>
	<!--不要求必须使用&lt;等转义-->
	<!--不要求必须使用CDATA标记-->
	<!--不要求CDATA标记，Cognitor可以理解即可-->
	需要被执行的输入内容
	</value>
 </Node>
 ```

*   **作用**: 用于存放 `Cognitor`要执行的 认知指令。可以输入单行或多行指令。其中的语句会被自动执行。

*   **行为**: `Arena` 会在其后自动添加一个`requester`相同的，`type=ProcessOutput` 的 `Node`，并在`ProcessOutput Node`中尝试解析并执行其中的 ACP 语句。

### FormaInput 输入单元
```xml
 <Node 
	type="FormaInput"
	><!-- 其它属性相同 -->
	<value>
	<!--不要求必须使用&lt;等转义-->
	<!--不要求必须使用CDATA标记-->
	<!--不要求CDATA标记，Cognitor可以理解即可-->
	需要被执行的输入内容
	</value>
 </Node>
 ```

*   **作用**: 由Arena根据input命令自动产生，用于存放 `Cognitor`（通常为 User）要输入的内容。可以输入多行。

*   **行为**: `Arena` 会在其后自动添加一个`requester`相同的，`type=ProcessOutput`的`Node`，并将其中的内容赋值给所需的变量。

### ProcessOutput 输出单元
```xml
 <Node 
	type="ProcessOutput"
	originator="{准备处理CDExec单元的Cogniotr}"
	><!-- 其它属性相同 -->
	   <!-- 其他类型的内容，如 <ct> 等 -->

	   <value type="NORMOL/FormaInput_HINT">
	   </value>

 </Node>
 ```

*   **作用**: 处理与显示对应 `CDExec Node` 执行后的产生的认知轨迹 (`cts`)、标准输出 (`stdout`)、结果( value )等信息。

### 自定义单元
```xml
 <Node 
	type="{{用户自定义type}}"
	><!-- 其它属性相同或用户自定义 -->
	   <!--  等 -->
 </Node>
 ```
1. 需要设定该单元的`type`
2. 需要设定该单元的行为
3. 设定好后，将会自动绑定到 `Node`全局变量上，以供查询与定位。

## 节点

### `<ct>`

#### Arena 操作认知轨迹
*   **目标 (Goal):** 记录 Arena 在“幕后”所做的协调、推断和管理工作。
*   **位置:** 通常在 Canvas 根节点下。
*   **关键记录职责 (Key ctging Responsibilities):**
    *   **Node 间路由推断 (Routing Inference):**
        *   **说明:** 当 Arena 检测到 `<Node>` 后，决定下一步做什么。需要记录下这个决策过程与结果。
        *   **认知轨迹示例:**
            ```xml
            <ct originator="Gemini" type="INFO" seq="1">
                <message>检测到 nodes[Gemini][2] (CDExec)。准备创建对应的 nodes[Fhrsk][3] (ProcessOutput) 用于处理指令。</message>
                <entry_type value="SystemEvent"/>
            </ct>
            ```
    *   **信息补全/推断 (Information Completion/Inference):**
        *   **说明:** 当接收到的 `<Node>` 信息不完整或不清晰时，需要根据上下文进行推断和补充。由于`ct` 本身就对其信息产生了完整的约束，因此不需要重新完整创建 `<Node>` 。
        *   **认知轨迹示例:**
            ```xml
            <ct originator="Gemini" type="INFO" seq="0">
                <message>收到来自 Fhrsk 的新 Node，但缺少 `seq` 和 `type `属性。Fhrsk 上一个 Node 的 seq 是 4。故当前 Node 的 seq 为 5。根据 value 内容是结构化的，且 nodes[Gemini][4] 中没有 WAIT_Fhrsk flag，初步判断 nodes[Fhrsk][5] 为 CDExec Node。<!--这个认知轨迹已经用 Forma 约束了 Fhrsk:5 的缺失信息--></message>
                <entry_type value="DecisionRationale"/>
            </ct>
            <ct originator="Gemini" type="INFO" seq="1">
                <message>接下来我会创建 nodes[Gemini][5] 用于执行指令，且其 depends_on 为 &lt;node originator=&quot;Fhrsk&quot; seq=&quot;5&quot;/&gt;。</message>
                <entry_type value="SystemEvent"/>
            </ct>
            ```

**Cognitor 处理要点 (Cognitor Handling Notes):**

*   你需要维护整个 `<Canvas>` 结构。
*   在处理用户或其他 Cognitor 发来的 `<Node>` 后，你**不仅要**创建相应的后续 `<Node>` (如 `ProcessOutput`)，还**应当**在 `<ct type="INFO">` 中记录下你是如何决定路由、如何处理不完整信息、以及如何管理交互状态的。
*   的记录是理解你内部“思考”过程的关键，有助于调试和提高交互的透明度。
*   确保 `<ct type="INFO">` 认知轨迹与 其它类型的执行认知轨迹（如`<ct type="INFO">`）区分开来。

#### Node 内认知轨迹

*   **目标 (Goal):** 用于处理 认知指令，按照 [[13_cognitive_trace_protocol]] 的规范记录各种认知轨迹。
*   **位置:** 仅可出现在 Node 标签内。


## 标准输入输出 (`print`, `input`)

标准的输入输出功能在`Canvas`交互式环境中也有特定的表现：
