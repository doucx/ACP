#  ACP Canvas 协议扩展
## 基本介绍
**ACP Canvas** 中的 **ACP 核心协议** 扩展规范。

## 核心原则
ACP Canvas 协议设计基于以下核心原则：
*   **纯文本交互**: ACP Canvas 的 Runtime Context 是纯文本。所有指令、数据和元信息都以文本形式交换。这意味着即使 `Cognitor` 通过实现 `Runtime` 模拟了函数、变量等高级概念，其状态和行为也**必须**通过文本日志进行记录和维护，以确保跨载体的一致性和可审计性。

## 核心实体
### Cognitor (认知执行体)

*   **定义** : 在典型的 Canvas 环境中，`Cognitor` 通常是指参与交互的**语言模型（如 ChatGPT）或人类用户** 。它们通过生成和理解文本来进行学习（适应对话流程）、推理（解释指令、生成代码/回答）和元认知（通过 `meta` 触发或内在反思）。其能力表现受限于具体的模型或个人，例如语言模型可能产生幻觉，人类则可能存在认知偏差，这些特性会反映在交互的文本和日志中。`Cognitor.info` 旨在捕获这些具体实例的元信息。

### Runtime (运行时环境)
*   **定义**: 在 Canvas 中，`Runtime` 的模拟过程主要通过当前负责执行的 `Cognitor`（通常是语言模型）**生成文本并管理 `Cell` 流**来体现。其运作方式包含以下关键方面：

    1.  **上下文维护:** 它通过解析用户输入 (`EXEC`, `INPUT` Cell) 和生成输出 (`OUTPUT` Cell，包含 `stdout`, `Logs`, `value` 等)，完全基于可见的文本历史（`Cell` 序列）来维护交互上下文。
    2.  **基于规则的 `Cell` 创建 (状态机行为):** `Runtime` (通过 `Cognitor` 的模拟) **主动监听并响应**特定事件或 `Cell` 状态，以按规则自动创建新的 `Cell`，驱动交互流程。这种“状态转换”机制主要包括：
        *   **`EXEC` -> `OUTPUT`:** 在处理完一个 `type="EXEC"` 的 `Cell` 后，自动创建一个对应的 `type="OUTPUT"` 的 `Cell` 来展示执行结果和日志。
        *   **`INPUT` -> `OUTPUT`:** 在用户提交一个 `type="INPUT"` 的 `Cell`（响应 `input()` 调用）后，自动创建一个新的 `type="OUTPUT"` `Cell` 来继续执行原 `EXEC` `Cell` 中 `input()` 之后的语句。
        *   **`input()` 调用 -> 等待 `INPUT`:** 当在 `EXEC` `Cell` 中遇到 `input()` 调用时，`Runtime` 会暂停当前 `OUTPUT` `Cell` 的生成，并将其标记为等待状态（例如，设置 `<value type="INPUT_HINT">` 和 `<flags><flag value="WAIT"/></flags>`)，**监听**用户创建并提交相应的 `type="INPUT"` `Cell`。
        *   **`Flag` 驱动创建:** 明确的 `Cell` 标记（如 `<flags><flag value="ThenCreateCell"/></flags>`）可以指示 `Runtime` 在处理完当前 `Cell` 后需要立即创建并处理一个（通常由 Fhrsk 或系统预定义的）新 `Cell`，而不只是等待用户输入。
    3.  **行为模拟:** `Runtime` 的其他行为，如自动将自然语言路由给 Fhrsk，也是 `Cognitor` 根据对文本流和 ACP Canvas 规则的**理解和模拟**来执行的。
    4.  **纯文本基础:** 其“纯文本”特性在 Canvas 中表现为结构化（如 XML 风格）的文本记录，整个交互流程和状态变迁都必须通过这些文本记录来体现。

## 交互
### 认知指令 (Cognitive Directive)
*   **定义** : 在 Canvas 交互中，认知指令通常表现为几种形式：**自然语言指令**（通常通过 `chat` 关键字或由 `Cognitor` 自动识别）、**类似特定编程语言（如 Python）的代码片段**，或 **ACP 特有的关键字/对象操作**（如 `Config.Loglevel = ...`, `Auto.autofill(...)`）。通常由语言模型 `Cognitor` 利用其强大的模式识别和语言理解能力来解析这些混合形式的语句，但也可能因缺乏严格语法而产生歧义或误解，需要通过日志或澄清性交互来解决。

### 信息表示

#### Uncertainty 不确定性实体
在典型的 Canvas 环境下（主要由语言模型或人类作为 `Cognitor`），`Uncertainty` 通常表现为一个**需要通过自然语言线索和上下文进行认知解读的模糊概念或指代**。当 `Cognitor` 遇到 `Uncertainty` 时，它会利用其**语言理解、常识知识和推理能力**来：
	  *   识别潜在的多种解释或可能性（处理歧义）。
	  *   根据对话历史、周围文本或提供的 `add_data` 信息，推断最相关的含义。
	  *   填充缺失的信息或细节（处理模糊性）。
	  *   生成一个当前看来最合理、最连贯的理解，并通过 `pick`, `to_module` 等方法将其（定性地）表达出来。
  *   因此，在 Canvas 中，`Uncertainty` 的处理过程更侧重于**模拟认知层面的不确定性导航**，而非精确的数学计算。其有效性高度依赖于 `Cognitor` 的**语境理解和生成合理推测**的能力。

#### Module 确定性实体
继承于 `Object`

在 ACP Canvas 中，Module 通常指一段文本的能指。


## 关键协议机制
### Logs (日志系统)

*   **定义** : 在 Canvas 中，`Logs` 由负责执行的 `Cognitor`（主要是语言模型）**以文本形式生成**，并嵌入到 `OUTPUT` Cell 的结构中（如 `<log>` 标签）。日志消息（`message` 字段）通常采用**自然语言叙述**的形式，反映 `Cognitor` 对其自身思考过程的**模拟或报告**（例如，`ReasoningNarrative`）。这些日志的详细程度、准确性甚至客观性会受到 `Cognitor` 能力和“意愿”的影响，可能包含冗余信息或需要通过 `flags` (如 `LLM_PossibleHallucination`) 提示潜在问题。人类 `Cognitor` 通常不会在 Canvas 中被要求生成同样详细的外显日志。

### `meta` (元认知指令关键字)

*   **定义** : 当语言模型或人类 `Cognitor` 在 Canvas 中遇到 `meta` 关键字时，通常会触发其生成一段**表现出（或模拟出）元认知活动的文本**。对于语言模型，这可能包括分析之前的输出、解释其推理步骤、讨论其理解的局限性、或进行更深层次的上下文关联。对于人类，这可能促使其进行更审慎的思考和表达。这种“元认知”的实现方式是**基于文本的、表达性的**，其深度和质量依赖于具体 `Cognitor` 的能力。