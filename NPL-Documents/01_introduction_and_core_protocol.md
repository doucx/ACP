# NPL 核心协议: 介绍与基础
## 1. NPL 简介

**NPL (Natural Pseudo Language)** 是一种**基于文本**的抽象的认知协作协议，旨在实现跨认知实体的智能交互。它定义了一套规范，使得不同的认知实体（`Cognitor`，文档中简称`载体`）能够通过 NPL 进行交流和协作，共同完成复杂的任务。

关键在于理解：它关注的是如何让不同的认知实体能够理解和执行相同的指令，记录相同的内容，以实现协作，而不是一种用于创造性表达的语言。

## 2. 核心原则

NPL 协议的设计基于以下核心原则：

*   **纯文本性**: NPL 的本质是纯文本协议。
	- 所有指令、数据和元信息都以且只以纯文本形式表示。即使 NPL Runtime 支持函数、变量、类等高级表达，它们本质上仍然是符号，并没有真正的底层特性。它们需要  `Runtime` 借助 `Cognitor` 手动维护（通过日志或其他形式的记录），以避免处理过程丢失，运算错误或产生歧义。
	- 这种纯文本性保证了 NPL 的跨载体兼容性和可审计性，但也对 `Cognitor` 的认知能力提出了更高的要求。
*   **跨载体兼容**: 同一段 NPL 代码/指令理论上可由不同类型的 `Cognitor`（AI、人类等）执行。
*   **能力导向**: 协议不限定 `Cognitor` 的技术实现，只要求其具备核心认知能力（见下文）。
*   **过程可审计**: 协议要求执行过程必须透明化，通常通过强制性的日志系统（Logs）来实现，以便追溯和理解。如模拟函数、变量、类等的底层特性。
*   **动态扩展**: 协议设计考虑了运行时切换或组合 `Cognitor` 的可能性（理论上）。
*   **基础可执行性**: 即使只提供核心协议（定义基本语法和语义）和示例（提供执行案例），NPL 也能进行基本的解析和执行，产生结果。
	* 这意味着 NPL 具有高度的独立性，不依赖于所有组件才能运行。其他组件（如运行时环境、兼容层、交互界面、标准库）旨在增强 NPL 的功能和易用性，而非实现基本可执行性所必需的。

## 3. 核心实体

NPL 协议围绕两个核心实体进行定义：

### 3.1. Cognitor (认知执行体)
*   **定义**: 指具备**学习、推理、元认知**这三大核心能力的执行实体。它可以是人工智能（如大型语言模型）、人类个体或团队，或其他满足能力要求的系统。`Cognitor` 是 NPL 指令的最终理解者和执行能力的来源。
*   **协议要求**: NPL 的有效运行**依赖于** `Cognitor` 具备上述三种认知能力。协议本身不提供这些能力，而是调用 `Cognitor` 的能力。
*   **识别机制**: 协议包含 `Cognitor.info` 机制，用于存储和传达当前参与交互的 `Cognitor` 的元信息（如名称、类型、能力简介等）。

### 3.2. Runtime (运行时环境)
注：当前定义混乱。修复进度 50%。（来自 0.0.x 的遗留，当时将所有 Cognitor 强行融合成一个 Runtime 进行处理）

*   **定义**: 由`Cognitor`根据协议维护（模拟）的，一个跨认知执行体的混合智能协同平台，负责维护和演进上下文（`Runtime.context`）。
*   **核心**: `Runtime` 维护一个**纯文本**格式的 `Runtime.context`，用于记录整个交互历史、环境变量状态、以及所有参与实体的相关信息。`Runtime.context` 是所有决策和行为的基础。
*   **纯文本的强调**: `Runtime.context` 本身是纯文本格式，这意味着所有信息都以文本形式存储和处理。所有未被显式记录在 `Runtime.context` 中的信息都可能丢失，例如用户的思考过程、输入时的省略内容、以及瞬时的状态变化。
*   **行为**: 在上下文更新后，`Runtime` 会根据整个上下文（对于任何表现出记忆连续性的 Cognitor（无论其内部机制如何），只需少量增量信息即可高效地理解和更新整体上下文。），并基于此触发接下来的行为。
*  **处理全上下文**：`Runtime` 的核心职责不是执行 NPL 语句，而是对整个交互上下文进行维护和处理，包括 路由、系统标记、日志信息标记。
*   **运行基础**: `Runtime` **依赖于**一个或多个 `Cognitor` 依照协议进行实现。它本身不直接拥有认知能力，而是作为 `Cognitor` 发挥能力的平台和 NPL 交互的执行环境。
*   **关键协议特性**:
	*   **载体无关性**: `Runtime` 的设计允许其运行在不同类型的 `Cognitor` 之上。
	*   **过程透明性**: `Runtime` **必须**通过协议定义的 **Logs** 机制来记录其执行过程，确保所有关键步骤和决策都可追溯。

## 4. 交互基础

### 4.1. NPL 语句

*   **形式**: NPL 的交互基于**文本语句**。
*   **内容**: 这些语句可以是任何 `Cognitor` 能够清晰理解的形式，包括但不限于自然语言指令、代码片段（多种语言）、或其他结构化文本。
*   **协议重点**: 协议不强制规定严格的语法，而是强调指令的**清晰性**和**可理解性**对于 `Cognitor` 的重要性。

### 4.2. 信息表示基础 (`Object`, `Module`, `Notion`)

NPL 协议定义了基础的对象模型来处理信息：

*   **`Object`**: NPL 中所有可思考、感知或讨论的事物的基类。
*   **`Module`**: 代表**确定性实体**。这类实体具有明确定义、可预测、可验证的特性（例如数学公式、已定义的数据结构）。
*   **`Notion`**: 代表**不确定性实体**。这类实体的确切含义、状态或未来走向不能完全确定，依赖于上下文信息进行推断（例如多义词、未解析的变量、模糊概念）。`Notion` 是 NPL 用于处理现实世界模糊性、多义性和潜在性的核心机制，是其区别于传统形式化系统的重要特征。

## 5. 关键协议机制

### 5.1. Logs (日志系统)

*   **协议定位**: Logs 是 NPL 协议**不可或缺**的一部分，是实现“过程透明性”原则的核心手段。
*   **功能**: 用于记录 `Runtime` 在执行 NPL 语句时的详细步骤、中间状态、决策路径、警告或错误。
*   **层级**: 协议定义了标准的日志层级（如 `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`），以提供不同粒度的过程信息。
*   **要求**: `Runtime` 实现**必须**生成符合协议规范的 Logs。

### 5.2. `meta` (元认知指令关键字)

*   **形式**: NPL 中的关键字 `meta`。
*   **协议作用**: `meta` 用于显式指示 `Cognitor` 在处理后续指令时**必须启用其元认知能力**。
*   **应用场景**: 这包括但不限于进行自我分析、处理涉及 `Runtime` 或 `Cognitor` 自身的指令（自我指涉）、解决潜在的递归或悖论结构、或进行更深层次的上下文理解和推理。`meta` 是协议中直接调用 `Cognitor` 高级认知功能的一种机制。
