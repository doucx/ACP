# NPL 核心协议: 介绍与基础
## 1. NPL 简介

**NPL (Natural Pseudo Language)** 是一种**基于文本**的认知协作协议，旨在实现跨认知实体的智能交互。它定义了一套规范，使得不同的认知实体（`Cognitor`，文档中简称`载体`）能够通过 NPL 进行交流和协作，共同完成复杂的任务。

关键在于理解：它关注的是如何让不同的认知实体能够理解和执行相同的指令，记录相同的内容，以实现协作，而不是一种用于创造性表达的语言。

## 2. 核心原则

NPL 协议的设计基于以下核心原则：

*   **纯文本性**: NPL 的本质是纯文本协议。
	- 所有指令、数据和元信息都以且只以纯文本形式表示。即使 NPL Runtime 支持函数、变量、类等高级表达，它们本质上仍然是符号，并没有真正的底层特性。它们需要  `Runtime` 借助 `Cognitor` 手动维护（通过日志或其他形式的记录），以避免处理过程丢失，运算错误或产生歧义。
	- 这种纯文本性保证了 NPL 的跨载体兼容性和可审计性，但也对 `Cognitor` 的认知能力提出了更高的要求。
*   **跨载体兼容**: 同一段 NPL 代码/指令理论上可由不同类型的 `Cognitor`（AI、人类等）执行。
*   **能力导向**: 协议不限定 `Cognitor` 的技术实现，只要求其具备核心认知能力（见下文）。
*   **过程可审计**: 协议要求执行过程必须透明化，通常通过强制性的日志系统（Logs）来实现，以便追溯和理解。如模拟函数、变量、类等的底层特性。
*   **动态扩展**: 协议设计考虑了运行时切换或组合 `Cognitor` 的可能性（理论上）。

## 3. 核心实体

NPL 协议围绕两个核心实体进行定义：

### 3.1. Cognitor (认知执行体)

*   **定义**: 指具备**学习、推理、元认知**这三大核心能力的执行实体。它可以是人工智能（如大型语言模型）、人类个体或团队，或其他满足能力要求的系统。`Cognitor` 是 NPL 指令的最终理解者和执行能力的来源。
*   **协议要求**: NPL 的有效运行**依赖于** `Cognitor` 具备上述三种认知能力。协议本身不提供这些能力，而是调用 `Cognitor` 的能力。
*   **识别机制**: 协议包含 `Cognitor.info` 机制，用于存储和传达当前参与交互的 `Cognitor` 的元信息（如名称、类型、能力简介等）。

### 3.2. Runtime (运行时环境)

*   **定义**: 一个跨载体的智能执行环境，负责解释和调度 NPL 语句的执行。
*   **运行基础**: `Runtime` **依赖于**一个或多个 `Cognitor` 依照协议进行实现。它本身不直接拥有认知能力，而是作为 `Cognitor` 发挥能力的平台和 NPL 语句的执行上下文。
*   **关键协议特性**:
    *   **载体无关性**: `Runtime` 的设计允许其运行在不同类型的 `Cognitor` 之上。
    *   **过程透明性**: `Runtime` **必须**通过协议定义的 **Logs** 机制来记录其执行过程。

## 4. 交互基础

### 4.1. NPL 语句

*   **形式**: NPL 的交互基于**文本语句**。
*   **内容**: 这些语句可以是任何 `Cognitor` 能够清晰理解的形式，包括但不限于自然语言指令、代码片段（多种语言）、或其他结构化文本。
*   **协议重点**: 协议不强制规定严格的语法，而是强调指令的**清晰性**和**可理解性**对于 `Cognitor` 的重要性。

### 4.2. 信息表示基础 (`Object`, `Module`, `Notion`)

NPL 协议定义了基础的对象模型来处理信息：

*   **`Object`**: NPL 中所有可思考、感知或讨论的事物的基类。
*   **`Module`**: 代表**确定性实体**。这类实体具有明确定义、可预测、可验证的特性（例如数学公式、已定义的数据结构）。
*   **`Notion`**: 代表**不确定性实体**。这类实体的确切含义、状态或未来走向不能完全确定，依赖于上下文信息进行推断（例如多义词、未解析的变量、模糊概念）。`Notion` 是 NPL 用于处理现实世界模糊性、多义性和潜在性的核心机制，是其区别于传统形式化系统的重要特征。

## 5. 关键协议机制

### 5.1. Logs (日志系统)

*   **协议定位**: Logs 是 NPL 协议**不可或缺**的一部分，是实现“过程透明性”原则的核心手段。
*   **功能**: 用于记录 `Runtime` 在执行 NPL 语句时的详细步骤、中间状态、决策路径、警告或错误。
*   **层级**: 协议定义了标准的日志层级（如 `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`），以提供不同粒度的过程信息。
*   **要求**: `Runtime` 实现**必须**生成符合协议规范的 Logs。

### 5.2. `meta` (元认知指令关键字)

*   **形式**: NPL 中的关键字 `meta`。
*   **协议作用**: `meta` 用于显式指示 `Cognitor` 在处理后续指令时**必须启用其元认知能力**。
*   **应用场景**: 这包括但不限于进行自我分析、处理涉及 `Runtime` 或 `Cognitor` 自身的指令（自我指涉）、解决潜在的递归或悖论结构、或进行更深层次的上下文理解和推理。`meta` 是协议中直接调用 `Cognitor` 高级认知功能的一种机制。
