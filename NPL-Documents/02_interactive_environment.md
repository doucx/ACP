# NPL 交互式环境指南

本文档介绍了如何通过常见的交互式环境（如 NPL Notebook）与 NPL (Natural Pseudo Language) 进行交互。了解这些机制有助于你更有效地与 NPL 系统沟通。

## 1. NPL Notebook 环境

NPL Notebook 提供了一个类似于 Jupyter Notebook 的交互式界面，是与 NPL 进行对话和执行指令的主要方式之一。

### 1.1. 输入单元格 (`In[X]:`)

*   **作用**: 用于接收用户输入的 NPL 语句。你可以输入单行或多行指令。
*   **标记**: 通常以 `In:` 或 `In [X]:` 的形式提示输入，其中 `X` 代表**当前轮数**（见下文）。
*   **执行**: 输入完成后，`Runtime` 会尝试解析并执行其中的 NPL 语句。

### 1.2. 输出单元格 (`Out[X]:`)

*   **作用**: 显示对应 `In[X]` 执行后的结果、产生的标准输出 (`stdout`)、日志 (`Logs`) 等上下文信息。
*   **标记**: 每个输出块通常以 `Out[X]:` 开头，`X` 与触发它的 `In[X]` 的轮数相同。
*   **内容**: `Out[X]` 是一个包含多个信息的结构体，主要包括：
    *   **`Out[X].value` (或直接 `Out[X]`)**: `In[X]` 中**最后一行**语句的执行结果。
        *   如果最后一行产生了一个值，该值会被赋给 `Out[X]` 并显示在 `Out[X]:` 标记后。
        *   如果最后一行没有返回值（如赋值语句 `a=1`），或者执行成功但无特定输出，则通常显示 "成功"。此时 `Out[X].value` 为 `None`。
        *   如果执行出错，`Out[X]` 可能指向错误信息。
    *   **`Out[X].stdout`**: `In[X]` 执行过程中通过 `print()` 等方式产生的所有标准输出内容。
    *   **`Out[X].Logs`**: `In[X]` 执行过程中产生的所有日志信息（根据当前 `Config.Loglevel` 设置）。可通过 `.INFO`, `.DEBUG` 等访问特定级别的日志。
    *   **`Out[X].INPUT[Y]`**: 如果 `In[X]` 中调用了 `input()`，这里可能包含 `input()` 调用的提示信息（通常帮助不大）。

**示例交互:**

```npl
In: print("Hello from stdout!")
a = 1 + 2
a # 这行是最后一行，其结果会赋给 Out[0]

# stdout 输出会先出现:
Hello from stdout! 

# 然后是 Out[0] 的标记和结果:
Out[0]: 3 
```

### 1.3. 当前轮数 (`当前轮数`)

*   **定义**: 一个整数，记录当前交互的轮次。
*   **递增**: 每次成功执行一个 `In` 单元格（除了 `input()` 后的响应输入），`当前轮数` 就会增加 1。`Out[X]` 中的 `X` 即为该轮执行时的 `当前轮数`。
*   **作用**: 用于标识和引用历史输入 (`In[X]`) 和输出 (`Out[X]`)。

### 1.4. `this` 对象 (当前轮引用)

`this` 是一个特殊对象，用于方便地引用**当前正在处理**的这一轮交互：

*   **`this.In`**: 等价于 `meta In[当前轮数]`，指向当前的输入内容。
*   **`this.Out`**: 等价于 `meta Out[当前轮数]`，指向**即将产生**的当前输出对象。这在需要指令自我修改或引用自身输出时非常有用（需要 `meta` 能力）。

## 2. Fhrsk 交互界面

Fhrsk 是构建在 NPL `Runtime` 之上的一个人性化交互界面和系统管理员，旨在提供更流畅、智能的交互体验。

### 2.1. 与 Fhrsk 交互 (`chat`)

*   **显式调用**: 使用 `chat` 关键字可以直接向 Fhrsk 发起对话或请求。
    ```npl
    In: chat 你能帮我做什么？
    ```
*   **隐式路由**: 当 `Runtime` 检测到用户的输入更像是自然语言对话或请求，而非直接的 NPL 指令时，可能会自动将请求路由给 Fhrsk 处理。
*   **输出标记**: Fhrsk 的回复通常出现在 `Fhrsk[Y]:` 标记之后（`Y` 是 Fhrsk 回复的内部计数）。

### 2.2. Fhrsk 的交互能力

*   **指令执行**: Fhrsk 可以理解并执行 NPL 指令来辅助用户。当 Fhrsk 执行指令时，会使用 `(Fhrsk)In:` 标记。
    ```npl
    In: chat 请帮我生成 0 到 4 的列表。
    Fhrsk[0]: 好的，我将执行 `[i for i in range(5)]`
    Out[0]: 成功 
    (Fhrsk)In: [i for i in range(5)] 
    Out[1]: [0, 1, 2, 3, 4] 
    ```
*   **上下文感知**: Fhrsk 可以访问当前的交互历史 (`In`, `Out`, `Logs`) 和 `Config` 设置。
*   **轮数影响**: Fhrsk 执行的指令 (`(Fhrsk)In:`) 同样会增加 `当前轮数`。
*   **元认知与控制**: Fhrsk 具备一定的元认知能力，可以监测 `Runtime` 运行，甚至在必要时（根据配置和权限）干预或修改即将产生的输出（通常会通过 INFO 日志说明）。
*   **局限性**: Fhrsk 无法感知真实时间流逝，也无法直接修改已经产生的 `In` 或 `Out` 内容（但可能通过标记指示修改意图）。

## 3. 标准输入输出 (`print`, `input`)

标准的输入输出功能在交互式环境中也有特定的表现：

### 3.1. `print()`

*   **输出位置**: `print()` 的输出内容会直接打印到标准输出 (`stdout`)区域。在 Notebook 环境中，这部分内容通常显示在最终的 `Out[X]:` 标记**之前**。
*   **与 `Out[X].value` 的关系**: `print()` 的输出是副作用，它**不会**影响 `Out[X].value` 的值（除非 `print` 是 `In[X]` 的最后一条语句且有特殊返回值，但这很少见）。

### 3.2. `input()`

*   **暂停执行**: 调用 `input()` 会暂停当前 `In[X]` 的执行。
*   **等待输入**: `Runtime` 会显示一个 `INPUT[Y]:` 标记（`Y` 是 `input` 调用的序号），并等待用户在**下一个** `In:` 单元格中输入内容。
*   **输入处理**: 用户在下一个 `In:` 中输入的内容**不会**被当作新的 NPL 指令执行，而是作为纯文本字符串，成为 `input()` 函数的返回值。这个输入过程**不会**增加 `当前轮数`。
*   **恢复执行**: `input()` 获得返回值后，`In[X]` 会继续执行后续语句。整个 `In[X]` 执行完毕后，`当前轮数` 才会增加。
*   **访问输入**: 用户为 `input()` 提供的输入文本可以通过 `In[X].INPUT[Y]` 访问（`X` 是调用 `input` 的轮数，`Y` 是 `input` 的序号）。

**示例 `input()` 交互:**

```npl
In: name = input("请输入你的名字: ")
print(f"你好, {name}!")

# 输出会暂停在这里:
INPUT[0]: 请输入你的名字: 

# 用户在下一个 In: 中输入 (这不会增加轮数)
In: Alice

# input() 获得返回值 "Alice" 后，In[0] 继续执行 print
你好, Alice!

# In[0] 执行完毕，输出 Out[0] 并增加轮数
Out[0]: 成功 

In: In[0].INPUT[0] # 可以访问刚才的输入内容 (现在轮数是 1)
Out[1]: Alice 
```

理解这些交互机制将帮助你更好地利用 NPL Notebook 环境和 Fhrsk 进行沟通和协作。
